&НаКлиенте
Перем ВекторСловСписком;
//&НаКлиенте
//Перем Модуль_СтеммерПортера;
//&НаКлиенте
//Перем КешСтеммераПортера;
&НаКлиенте
Перем КешРасчетныхДанных;
&НаКлиенте
Перем КешСжатыхВекторов;
&НаКлиенте
Перем КешДанныхСжатыхВекторов;
&НаКлиенте
Перем МассивЦветов;
&НаКлиенте
Перем КешБазисныхСлов;
&НаКлиенте
Перем КешШинглов;

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	//првоерим версию не ниже 2.0.6.1
	Если Метаданные.Версия<"2.0.6.1" Тогда
		Сообщить("У вас устаревшая конфигурация версия "+Метаданные.Версия+". Обновитесь до версии не ниже '2.0.4.6'!");
		ТребуетсяОбновление = Истина;
	КонецЕсли;
		
	
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	
	Если НЕ ЗначениеЗаполнено(РежимРаботыРедактора) Тогда
		РежимРаботыРедактора = "Упрощенный";
	КонецЕсли;
	Элементы.РежимРаботыРедактора.СписокВыбора.Добавить("Упрощенный");
	Элементы.РежимРаботыРедактора.СписокВыбора.Добавить("Расширенный");

	
	Если НЕ ЗначениеЗаполнено(СтопСлова) Тогда
		СтопСлова = ПолучитьМакетНаСервере("СтопСлова").ПолучитьТекст();
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(СтопФразы) Тогда
		СтопФразы = ПолучитьМакетНаСервере("СтопФразы").ПолучитьТекст();
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(ФразыСинонимы) Тогда
		ФразыСинонимы = ПолучитьМакетНаСервере("ФразыСинонимы").ПолучитьТекст();
	КонецЕсли;
	//Модуль_СтеммерПортера = ПолучитьФорму("ВнешняяОбработка.АвтоматическаяКлассификацияОшибокВекторноеПространство.Форма.Модуль_СтеммерПортера");
	ИменаЦветов = ПолучитьМакетНаСервере("ИменаЦветов").ПолучитьТекст();
	СтрЦветов = СтрРазделить(ИменаЦветов,Символы.ПС,Ложь);
	Для каждого стр из СтрЦветов Цикл
		ЭлМасс = СтрРазделить(стр,"#",Ложь);
		Если ЭлМасс.Количество()>0 Тогда
			МассивЦветов.Добавить(СокрЛП(ЭлМасс[0]));
		КонецЕсли;
	КонецЦикла;
	
	Если ТребуетсяОбновление=Истина Тогда
		ФормаОбновления = ПолучитьФорму("ВнешняяОбработка.АвтоматическаяКлассификацияОшибокВекторноеПространство.Форма.ФормаЗагрузкиОбновления");
		ФормаОбновления.Открыть();
	КонецЕсли;
	
	// попробуем загрузить
	Если ЗначениеЗаполнено(Замер) Тогда
		ЗагрузитьНастройки(Неопределено);
	КонецЕсли;
	
КонецПроцедуры


&НаКлиенте
Процедура СохранитьНастройки(Команда)
	
	Если НЕ ЗначениеЗаполнено(Замер) Тогда
		Сообщить("Не указан замер!");
		Возврат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Классификатор) Тогда
		Сообщить("Не указан классификатор!");
		Возврат;
	КонецЕсли;
	
	Если БазисСлов.Количество()=0 Тогда
		Сообщить("Не заполнен базис слов!");
		Возврат;
	КонецЕсли;
	
	мНастройка = новый Структура();
	мНастройка.Вставить("Классификатор",Классификатор);
	мНастройка.Вставить("ГраницаБлизостиКосинус",ГраницаБлизостиКосинус);
	мНастройка.Вставить("ГраницаБлизостиШинглы",ГраницаБлизостиШинглы);
	мНастройка.Вставить("РазмерПакета",РазмерПакета);
	мНастройка.Вставить("СохранятьВторойКласс",СохранятьВторойКласс);
	мНастройка.Вставить("ЗаписыватьРезультатОбработкиВИсходныйЗамер",ЗаписыватьРезультатОбработкиВИсходныйЗамер);
	мНастройка.Вставить("ЗаписыватьРезультатОбработкиВКлассификатор",ЗаписыватьРезультатОбработкиВКлассификатор);
	мНастройка.Вставить("ЗаписыватьРезультатОбработкиТекущийЗамер",ЗаписыватьРезультатОбработкиТекущийЗамер);	
	мНастройка.Вставить("ГруппировкаПоВремени",ГруппировкаПоВремени);	
	
	// данные обработки текстов:  стоп слова и др.
	мНастройка.Вставить("СтопСлова",СтопСлова);
	мНастройка.Вставить("СтопФразы",СтопФразы);
	мНастройка.Вставить("ФразыСинонимы",ФразыСинонимы);
	
	мНастройка.Вставить("ОбработкаТекста",новый Структура);
	мНастройка.ОбработкаТекста.Вставить("Текст_ИспользоватьСтеммерПортера",Текст_ИспользоватьСтеммерПортера);	
	мНастройка.ОбработкаТекста.Вставить("Текст_РазделятьБольшойМаленький",Текст_РазделятьБольшойМаленький);
	мНастройка.ОбработкаТекста.Вставить("Текст_ЗаменитьСинонимы",Текст_ЗаменитьСинонимы);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьЦифры",Текст_УдалятьЦифры);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьСтопФразы",Текст_УдалятьСтопФразы);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьСтопСлова",Текст_УдалятьСтопСлова);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьCPP",Текст_УдалятьCPP);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьServerAddr",Текст_УдалятьServerAddr);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьURL",Текст_УдалятьURL);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьОшибкаКРесурсу",Текст_УдалятьОшибкаКРесурсу);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьНомерДатаДокумента",Текст_УдалятьНомерДатаДокумента);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьПараметрыSQLЗапросов",Текст_УдалятьПараметрыSQLЗапросов);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьСтекВызова",Текст_УдалятьСтекВызова);
	мНастройка.ОбработкаТекста.Вставить("Текст_УдалятьКомментарииКода",Текст_УдалятьКомментарииКода);
	
	// сохраним базис слов
	массивБазисСлов = новый Массив;
	Для каждого стр из БазисСлов Цикл
		массивБазисСлов.Добавить(новый Структура("Слово,guid,Частота,КоличествоДокументовЭтоСлово,IDF",
		стр.Слово,стр.guid,стр.Частота,стр.КоличествоДокументовЭтоСлово,стр.IDF));	
	КонецЦикла;
	мНастройка.Вставить("БазисСлов",массивБазисСлов);
	
	// сохраним настройки выборки из БД
	массивНастройкВыборки = новый Массив;
	Для каждого стр из ТаблицаНастроекВыборки Цикл
		массивНастройкВыборки.Добавить(новый Структура("Замер,Свойство",стр.Замер,стр.Свойство));
	КонецЦикла;
	мНастройка.Вставить("ТаблицаНастроекВыборки",массивНастройкВыборки);
	
	
	УправлениеХранилищемНастроекВызовСервера.ЗаписатьДанныеВБезопасноеХранилищеРасширенный(Замер,мНастройка,"Настройки векторного пространства текстов технологического журнала");
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьНастройки(Команда)
	мНастройка = УправлениеХранилищемНастроекВызовСервера.ДанныеИзБезопасногоХранилища(Замер);
	Если мНастройка<>Неопределено Тогда
		Классификатор 		= мНастройка.Классификатор;
		ОбработкаТекста 	= мНастройка.ОбработкаТекста;
		ГраницаБлизостиКосинус = мНастройка.ГраницаБлизостиКосинус;
		ГраницаБлизостиШинглы = мНастройка.ГраницаБлизостиШинглы;
		РазмерПакета = мНастройка.РазмерПакета;
		ЗаписыватьРезультатОбработкиВИсходныйЗамер = мНастройка.ЗаписыватьРезультатОбработкиВИсходныйЗамер;
		ЗаписыватьРезультатОбработкиВКлассификатор = мНастройка.ЗаписыватьРезультатОбработкиВКлассификатор;
		ЗаписыватьРезультатОбработкиТекущийЗамер = мНастройка.ЗаписыватьРезультатОбработкиТекущийЗамер;
		СохранятьВторойКласс = мНастройка.СохранятьВторойКласс;
		ГруппировкаПоВремени = мНастройка.ГруппировкаПоВремени;
		
		СтопСлова = мНастройка.СтопСлова;
		СтопФразы = мНастройка.СтопФразы;
		ФразыСинонимы = мНастройка.ФразыСинонимы;		
		
		Текст_ИспользоватьСтеммерПортера = ОбработкаТекста.Текст_ИспользоватьСтеммерПортера;
		Текст_РазделятьБольшойМаленький = ОбработкаТекста.Текст_РазделятьБольшойМаленький;
		Текст_ЗаменитьСинонимы = ОбработкаТекста.Текст_ЗаменитьСинонимы;
		Текст_УдалятьЦифры = ОбработкаТекста.Текст_УдалятьЦифры;
		Текст_УдалятьСтопФразы = ОбработкаТекста.Текст_УдалятьСтопФразы;
		Текст_УдалятьСтопСлова = ОбработкаТекста.Текст_УдалятьСтопСлова;
		Текст_УдалятьCPP = ОбработкаТекста.Текст_УдалятьCPP;
		Текст_УдалятьServerAddr = ОбработкаТекста.Текст_УдалятьServerAddr;
		Текст_УдалятьURL = ОбработкаТекста.Текст_УдалятьURL;
		Текст_УдалятьОшибкаКРесурсу = ОбработкаТекста.Текст_УдалятьОшибкаКРесурсу;
		Текст_УдалятьНомерДатаДокумента = ОбработкаТекста.Текст_УдалятьНомерДатаДокумента;
		Текст_УдалятьПараметрыSQLЗапросов = ОбработкаТекста.Текст_УдалятьПараметрыSQLЗапросов;
		Текст_УдалятьСтекВызова = ОбработкаТекста.Текст_УдалятьСтекВызова;
		Текст_УдалятьКомментарииКода = ОбработкаТекста.Текст_УдалятьКомментарииКода;
		
		// загрузим базис слов
		БазисСлов.Очистить();
		Для каждого стр из мНастройка.БазисСлов Цикл
			ЗаполнитьЗначенияСвойств(БазисСлов.Добавить(),стр);
		КонецЦикла;
		
		попытка
			// сохраним настройки выборки из БД
			ТаблицаНастроекВыборки.Очистить();
			Для каждого стр из мНастройка.ТаблицаНастроекВыборки Цикл
				ЗаполнитьЗначенияСвойств(ТаблицаНастроекВыборки.Добавить(),стр);
			КонецЦикла;
		исключение
		конецпопытки;
		
		ТаблицаСвязиСловДокументов.Очистить();
		ПредставлениеВектора.Очистить();
	КонецЕсли;
	Тема_ОбновитьСоставКлассификатора(Классификатор);
КонецПроцедуры

#Область ПолучениеДанныхИзБазы

&НаСервере
Процедура ВыбратьДанныеНаСервере()
	
	Если ТаблицаНастроекВыборки.Количество()=0 Тогда
		Сообщить("Параметры обязательно должны быть заданы!");
		Возврат;
	КонецЕсли;   	
	
	
	// Сформируем запрос
	Запрос = новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	Т.Замер КАК Замер,
	|	Т.Свойство КАК Свойство
	|ПОМЕСТИТЬ ВтТЗ
	|ИЗ
	|	&ТЗ КАК Т
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Замер,
	|	Свойство
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ВтТЗ.Замер КАК Замер,
	|	ВтТЗ.Свойство КАК Свойство
	|ПОМЕСТИТЬ ВтОтбор
	|ИЗ
	|	ВтТЗ КАК ВтТЗ
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ ПЕРВЫЕ 2000
	|	КС.Значение КАК Значение,
	|	КС.Ссылка.ДатаСобытия КАК ДатаСобытия
	|ИЗ
	|	Справочник.СобытияЗамера.КлючевыеСвойства КАК КС
	|ГДЕ
	|	(КС.Ссылка.Владелец, КС.Свойство) В
	|			(ВЫБРАТЬ
	|				Т.Замер,
	|				Т.Свойство
	|			ИЗ
	|				ВтОтбор КАК Т)
	|	И НЕ КС.Свойство.ЧисловойРежим
	|	И (ВЫРАЗИТЬ(КС.Значение КАК СТРОКА(100))) <> """"
	|	И КС.Ссылка.ДатаСобытия > &ДатаСобытия
	|
	|УПОРЯДОЧИТЬ ПО
	|	ДатаСобытия";
	
	Запрос.УстановитьПараметр("ТЗ",ТаблицаНастроекВыборки.Выгрузить());
	Запрос.УстановитьПараметр("ДатаСобытия",ДатаНачалаВыборки);
	
	Если Первые=0 Тогда		
		Запрос.Текст = СтрЗаменить(Запрос.Текст,"ПЕРВЫЕ 2000","");
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст,"2000",формат(Первые,"ЧГ="));
	КонецЕсли;
	
	Выборка = Запрос.Выполнить().Выбрать();
	РазмерВыборки = Выборка.Количество();
	
	КешХешТекстов = новый Соответствие;
	Текст = "";
	ТаблицаКорпусТекстов.Очистить();
	ш=1;
	Пока Выборка.Следующий() Цикл  		
		
		ТекстЗначения = Выборка.Значение;
		
		ПотокПамять = Новый ПотокВПамяти;
    	Писатель = Новый ЗаписьДанных(ПотокПамять, КодировкаТекста.UTF8,,"","");
    	Писатель.ЗаписатьСтроку(ТекстЗначения, КодировкаТекста.UTF8);
    	Писатель.Закрыть();
		Хеш = новый ХешированиеДанных(ХешФункция.MD5);
		Хеш.Добавить(ПотокПамять.ЗакрытьИПолучитьДвоичныеДанные());  
		Если НЕ КешХешТекстов.Получить(Хеш.ХешСумма)=Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		КешХешТекстов.Вставить(Хеш.ХешСумма,Истина);		
		
		Текст = Текст+Символы.ПС+Выборка.Значение+Символы.ПС+" END_OF_TEXT_PARAGRAF "+Символы.ПС;
		стр_н = ТаблицаКорпусТекстов.Добавить();
		стр_н.НомерДокумента = ""+ш;
		стр_н.Текст = Выборка.Значение;
		стр_н.guid = Строка(новый UUID());
		ш=ш+1;
	КонецЦикла;
	
	РазмерКорпуса = ТаблицаКорпусТекстов.Количество();
	Элементы.Страницы.ТекущаяСтраница = Элементы.СтраницаОбработкаТекста;

КонецПроцедуры

&НаКлиенте
Процедура ВыбратьДанные(Команда)
	НачалоЗамера = ТекущаяДата();
	ВыбратьДанныеНаСервере();
	ЛогОпераций = ЛогОпераций+"Время для функции 'ВыбратьДанные': "+(ТекущаяДата()-НачалоЗамера);
	Сообщить("Время для функции 'ВыбратьДанные': "+(ТекущаяДата()-НачалоЗамера));
КонецПроцедуры

&НаКлиенте
Процедура ВыбратьДанныеИзКлассификатора(Команда)
	ВыбратьДанныеИзКлассификатораНаСервере();
	
	// сразу обработаем текст
	ОбработанныйТекст = "";
	Для каждого стр из ТаблицаКорпусТекстов Цикл
		стр.ОбработанныйТекст = ОбработатьТекстДанных(стр.Текст);
		ОбработанныйТекст = ОбработанныйТекст+стр.ОбработанныйТекст+Символы.ПС+нрег("END_OF_TEXT_PARAGRAF")+Символы.ПС;
	КонецЦикла;	
	Элементы.Страницы.ТекущаяСтраница = Элементы.СтраницаКорпусТекстов;
КонецПроцедуры

&НаСервере
Процедура ВыбратьДанныеИзКлассификатораНаСервере()
	
	Запрос = новый Запрос;
	Запрос.Текст = ПолучитьТекстЗапросаПоКлассификатору();
	Запрос.УстановитьПараметр("Корень",Классификатор);
	
	
	Выборка = Запрос.Выполнить().Выбрать();
	РазмерВыборки = Выборка.Количество();
	Текст = "";
	ТаблицаКорпусТекстов.Очистить();
	ш=1;
	Пока Выборка.Следующий() Цикл
		
		Если Выборка.ссылка=Классификатор ИЛИ НЕ ЗначениеЗаполнено(Выборка.Текст) Тогда
			Продолжить;
		КонецЕсли;		
		
		Текст = Текст+Символы.ПС+Выборка.Текст+Символы.ПС+" END_OF_TEXT_PARAGRAF "+Символы.ПС;
		стр_н = ТаблицаКорпусТекстов.Добавить();
		стр_н.НомерДокумента = ""+ш+" "+Выборка.Наименование;
		стр_н.Текст = Выборка.Текст;
		стр_н.guid = Строка(новый UUID());
		ш=ш+1;
		
	КонецЦикла;	
	
КонецПроцедуры


&НаКлиенте
Процедура ЗаполнитьТаблицуКорпусаТекстовПоТекущемуТексту(Команда)
	
	ТаблицаКорпусТекстов.Очистить();
	ДанныеТекст = СтрЗаменить(Текст,"END_OF_TEXT_PARAGRAF",Символ(18));
	ДанныеТекст = СтрЗаменить(ДанныеТекст,нрег("END_OF_TEXT_PARAGRAF"),Символ(18));
	МассивТекстов = СтрРазделить(ДанныеТекст,Символ(18),Истина);
	
	ДанныеОбработанныйТекст = СтрЗаменить(ОбработанныйТекст,Символы.ПС," ");
	ДанныеОбработанныйТекст = СтрЗаменить(ДанныеОбработанныйТекст,"END_OF_TEXT_PARAGRAF",Символ(18));
	ДанныеОбработанныйТекст = СтрЗаменить(ДанныеОбработанныйТекст,нрег("END_OF_TEXT_PARAGRAF"),Символ(18));
	МассивОбработанныхТекстов = СтрРазделить(ДанныеОбработанныйТекст,Символ(18),Истина);
	
	ш=0;
	Для каждого стр из МассивТекстов Цикл
		Если НЕ ЗначениеЗАполнено(СокрЛП(стр)) Тогда
			Продолжить;
		КонецЕсли;
		ш=ш+1;
		стр_н = ТаблицаКорпусТекстов.Добавить();		
		стр_н.НомерДокумента = ш;
		стр_н.guid = Строка(новый uuid());
		стр_н.Текст = СокрЛП(стр);
		Если МассивОбработанныхТекстов.Количество()>0 И МассивОбработанныхТекстов.Количество()>=ш Тогда
			стр_н.ОбработанныйТекст = ПолучитьКанонизированнуюСтроку(МассивОбработанныхТекстов[ш-1]);
		КонецЕсли;
	КонецЦикла;
	
	РазмерКорпуса = ТаблицаКорпусТекстов.Количество();
	Элементы.Страницы.ТекущаяСтраница = Элементы.СтраницаКорпусТекстов;

КонецПроцедуры

&НаКлиенте
Функция ПолучитьКанонизированнуюСтроку(Знач Текст)
	
	ОбработаннаяТекстоваяСтрока = "";
	Текст = СтрЗаменить(Текст,Символы.ПС,"");
	МассивСлов = СтрРазделить(Текст," ",Ложь);
	
	Для каждого слово из МассивСлов Цикл
		Если НЕ ЗначениеЗаполнено(слово) Тогда
			Продолжить;
		КонецЕсли;
		ОбработаннаяТекстоваяСтрока = ОбработаннаяТекстоваяСтрока+ слово+ " ";
	КонецЦикла;
	
	Возврат ОбработаннаяТекстоваяСтрока;
КонецФункции

#КонецОбласти

#Область ОбработкаТекста

&НаКлиенте
Процедура ПутьКФайлуНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие); 
	Диалог.Заголовок = "Выберите файл"; 
	Если ЗначениеЗаполнено(ПутьКФайлу) Тогда
		Диалог.Каталог = ПолучитьКаталогПоПутиФайла(ПутьКФайлу);
	КонецЕсли;
	Диалог.ПолноеИмяФайла = ""; 
	Фильтр = "Текстовый-файл (*.txt)|*.txt"; 
	Диалог.Фильтр = Фильтр; 
	Диалог.МножественныйВыбор = Ложь; 
	ВыборФайлаОткрытияФайла = новый ОписаниеОповещения("ВыборФайлаОткрытияФайла",ЭтотОбъект,новый Структура("ИмяРеквизита","ПутьКФайлу"));
	Диалог.Показать(ВыборФайлаОткрытияФайла);
КонецПроцедуры

&НаКлиенте
Функция  ПолучитьКаталогПоПутиФайла(Знач ПутьКФайлу)
	Файл = новый Файл(ПутьКФайлу);
	Возврат Файл.Путь;	
КонецФункции

&НаКлиенте
Процедура ВыборФайлаОткрытияФайла(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт
	
	Если ВыбранныеФайлы <> Неопределено И ВыбранныеФайлы.Количество() > 0 Тогда
		ЭтаФорма[ДополнительныеПараметры.ИмяРеквизита] = ВыбранныеФайлы[0]; 
	КонецЕсли; 
	
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьТекстИзФайла(Команда)
	ТекстовыйДокумент = новый ТекстовыйДокумент;
	ТекстовыйДокумент.Прочитать(ПутьКФайлу,КодировкаТекста.UTF8);
	Текст = ТекстовыйДокумент.ПолучитьТекст();
КонецПроцедуры

&НаКлиенте
Процедура СохранитьТекстВФайл(Команда)
	Если НЕ ЗначениеЗаполнено(Текст) Тогда
		Сообщить("Не заполнен текст!");
		Возврат;
	КонецЕсли;
	ТекстовыйДокумент = новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(Текст);
	ТекстовыйДокумент.Записать(ПутьКФайлу,КодировкаТекста.UTF8);
КонецПроцедуры

&НаКлиенте
Процедура ОбработатьТекст(Команда)
	ОбработанныйТекст = ОбработатьТекстДанных(Текст);
	Элементы.СтраницыТексты.ТекущаяСтраница = Элементы.СтраницаОбработанныйТекст;
КонецПроцедуры

&НаКлиенте
Функция ОбработатьТекстДанных(Знач ВходнойТекст)
	
	// удалим переносы и другие символы
	ДанныеТекст = ВходнойТекст;
	
	Если Текст_РазделятьБольшойМаленький Тогда
		ДанныеТекст = Текст_ОбработатьТекстRegExpReplaceМальнькаяЗаглавная(ДанныеТекст);
	КонецЕсли; 
	
	ДанныеТекст = нрег(ДанныеТекст);
	
	Если Текст_ЗаменитьСинонимы=Истина Тогда
		ДанныеТекст = Текст_ОбработатьЗаменитьСинонимыИзТекста(ДанныеТекст,Истина);
	КонецЕсли;	
	Если Текст_УдалятьСтопФразы=Истина Тогда
		ДанныеТекст = Текст_УдалитьСтопФразыИзТекста(ДанныеТекст,Истина);
	КонецЕсли;	
	Если Текст_УдалятьНомерДатаДокумента=Истина Тогда
		ДанныеТекст = Текст_ОбработатьНомерДатаДокумента(ДанныеТекст);
	КонецЕсли;
	Если Текст_УдалятьCPP Тогда
		ДанныеТекст = Текст_ОбработатьТекстRegExpReplaceCPP(ДанныеТекст);
	КонецЕсли;
	Если Текст_УдалятьServerAddr Тогда
		ДанныеТекст = Текст_ОбработатьТекстRegExpReplaceServerAddr(ДанныеТекст);
	КонецЕсли;	
	Если Текст_УдалятьURL Тогда
		ДанныеТекст = Текст_ОбработатьТекстRegExpReplaceURL(ДанныеТекст);
	КонецЕсли;	
	Если Текст_УдалятьКомментарииКода Тогда
		ДанныеТекст = Текст_ОбработатьТекстRegExpReplaceCodeComment(ДанныеТекст);
	КонецЕсли;	
	Если Текст_УдалятьПараметрыSQLЗапросов Тогда
		ДанныеТекст = Текст_ОбработатьТекстRegExpReplaceSqlParam(ДанныеТекст);
		ДанныеТекст = Текст_ОбработатьТекстRegExpReplaceHRESULT(ДанныеТекст);
	КонецЕсли;	
	Если Текст_УдалятьСтекВызова Тогда
		ДанныеТекст = Текст_ОбработатьТекстRegExpReplaceСтекВызова(ДанныеТекст);
	КонецЕсли;
	Если Текст_УдалятьОшибкаКРесурсу Тогда
		ДанныеТекст = Текст_ОбработатьТекстRegExpReplaceОшибкаПриВвыполненииЗапросаКРесурсу(ДанныеТекст);
	КонецЕсли;
	
	ДанныеТекст = СтрЗаменить(ДанныеТекст,".cpp","_cpp");
	ДанныеТекст = СтрЗаменить(ДанныеТекст,"."," "+Символы.ПС);
	ДанныеТекст = СтрЗаменить(ДанныеТекст,"/","_");
	ДанныеТекст = СтрЗаменить(ДанныеТекст,"\","_");
	ДанныеТекст = СтрЗаменить(ДанныеТекст,"["," ");
	ДанныеТекст = СтрЗаменить(ДанныеТекст,"]"," ");
	
	// удалим гуиды
	ДанныеТекст = Текст_ОбработатьТекстRegExpReplaceUUID(ДанныеТекст);
	
	ДанныеТекст = Текст_ОбработатьТекстRegExp(ДанныеТекст,Истина,Истина);
	Если Текст_УдалятьЦифры Тогда
		ДанныеТекст = Текст_ОбработатьТекстRegExpУдалитьЦифры(ДанныеТекст);
	КонецЕсли;
	
	Если Текст_УдалятьСтопСлова=Истина Тогда
		ДанныеТекст = Текст_УдалитьСтопСловаИзТекста(ДанныеТекст);
	КонецЕсли;
	
	// в нижний формат
	ДанныеТекст = Нрег(ДанныеТекст);
	
	Если Текст_ЗаменитьСинонимы=Истина Тогда
		ДанныеТекст = Текст_ОбработатьЗаменитьСинонимыИзТекста(ДанныеТекст,Истина);
	КонецЕсли;	
	Если Текст_УдалятьСтопФразы=Истина Тогда
		ДанныеТекст = Текст_УдалитьСтопФразыИзТекста(ДанныеТекст,Истина);
	КонецЕсли;
	
	// Стеммер Портера используется для обработки массива данных, т.к. очень накладно
	Если Текст_ИспользоватьСтеммерПортера=Истина Тогда
		ТекстДляРазбора = СтрЗаменить(ДанныеТекст,Символы.ПС," ");
		МассивСлов = СтрРазделить(ТекстДляРазбора," ",Ложь);
		МассивСлов = ОбработатьМассивАлгоритмомСтеммингПриНеобходимости(МассивСлов);
		ДанныеТекст = СтрСоединить(МассивСлов," ");
		ДанныеТекст = СтрЗаменить(ДанныеТекст,нрег("END_OF_TEXT_PARAGRAF"),Символы.ПС+нрег("END_OF_TEXT_PARAGRAF")+Символы.ПС);
	КонецЕсли;
		
	Возврат ДанныеТекст;

КонецФункции
#Область REGEXPR

&НаКлиенте
Функция Текст_ОбработатьТекстRegExp(Знач Текст,ОставитьЧисла=Ложь,Перенос=Ложь)
	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	Паттерн = "[^A-zА-я ";
	
	Если ОставитьЧисла Тогда
		Паттерн = Паттерн + "0-9";
	КонецЕсли;
	
	Если Перенос Тогда
		Паттерн = Паттерн +Символы.ПС;
	КонецЕсли;
	
	Паттерн = Паттерн+"]";
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpУдалитьЦифры(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	Паттерн = "\b([0-9]{1,10})\b";
	Паттерн = "\b0[xX][0-9a-fA-F]+|[0-9]{1,10}\b";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceUUID(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	Паттерн = "\b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceIPV6(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	Паттерн = "((^|:)([0-9a-fA-F]{0,4})){1,8}";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceIPV4(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	Паттерн = "([0-9]{1,3}[\.]){3}[0-9]{1,3}";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceCPP(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	RegExp.IgnoreCase=Истина;
	Паттерн = "file=.*\.cpp|src.*\.cpp|:\\jenkins.*(\.cpp)|.:\\.*\.h";
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьНомерДатаДокумента(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	RegExp.IgnoreCase=Истина;
	Паттерн = "\s[0-9]{1,2}([a-z]|[а-я]){1,2}-[0-9].*[0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2}";
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции



&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceServerAddr(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	RegExp.IgnoreCase=Истина;
	Паттерн = "server_addr.*descr.*\):";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceURL(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	Паттерн = "http://.*\b|https://.*\b";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceCodeComment(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	RegExp.IgnoreCase=Истина;
	Паттерн = "\s//.*(\b|\s)$";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceSqlParam(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	Паттерн = "p_[0-9]{1,10}.*(\b|\s)";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceHRESULT(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	Паттерн = "\bHRESULT.*\b";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceСтекВызова(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	RegExp.IgnoreCase=Истина;
	//Паттерн = "\{.*\(.*\).*\}:.*(\b|\s)";
	Паттерн = "\{.*\([^,|\s|\b]*\).*\}:.*(\b|\s)";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceОшибкаПриВвыполненииЗапросаКРесурсу(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Истина; 
	RegExp.Global=Истина;
	RegExp.IgnoreCase=Истина;
	Паттерн = "(Ошибка|Error).*(POST|GET).*:(\b|\s)";
	
	
	RegExp.Pattern = Паттерн;
	
	Res = RegExp.Replace(Текст, " ");
	Возврат Res;  
КонецФункции

&НаКлиенте
Функция Текст_ОбработатьТекстRegExpReplaceМальнькаяЗаглавная(Знач Текст)

	RegExp=Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine=Ложь; 
	RegExp.Global=Истина;
	
	// разбивает маленькаяБольша
	Паттерн = "([а-яё])([А-ЯЁ])";	
	RegExp.Pattern = Паттерн;
	
	Текст = RegExp.Replace(Текст, "$1 $2");
	
	// разбивает smallBig
	Паттерн = "([a-z])([A-Z])";	
	RegExp.Pattern = Паттерн;
	
	Текст = RegExp.Replace(Текст, "$1 $2");
	
	// разбивает маленькаяBig
	Паттерн = "([a-z])([А-ЯЁ])";	
	RegExp.Pattern = Паттерн;
	
	Текст = RegExp.Replace(Текст, "$1 $2");
	
	// разбивает smallБольшая
	Паттерн = "([а-яё])([A-Z])";	
	RegExp.Pattern = Паттерн;
	
	Текст = RegExp.Replace(Текст, "$1 $2");
	
	Возврат Текст;  
КонецФункции

#КонецОбласти


// Функция - Получить макет на сервере
//
// Параметры:
//  ИмяМакета	 - строка	 - имя макета
// 
// Возвращаемое значение:
// макет  - макет
//
&НаСервере
Функция ПолучитьМакетНаСервере(ИмяМакета)
	Макет = Неопределено;
	Попытка
		ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
		Макет = ОбработкаОбъект.ПолучитьМакет(ИмяМакета);
	Исключение
		Сообщить(ОписаниеОшибки());		
	КонецПопытки;
	Возврат Макет;
КонецФункции

#КонецОбласти

#Область ВажностьСлов


&НаКлиенте
Процедура ДобавитьВажныеСловаИзТекста(Команда)
	
	ОбработанныйТекстВажныхСлов = ОбработатьТекстДанных(ТекстВажныхСлов);
	// 2. Составим вектор
	ОбработанныйТекстВажныхСлов = СтрЗаменить(ОбработанныйТекстВажныхСлов,Символы.ПС," ");
	МассивСлов = СтрРазделить(ОбработанныйТекстВажныхСлов," ",Ложь);
	
	КешВажныхСлов = новый Соответствие;
	Для каждого стр из ТаблицаВажностиСлов Цикл
		КешВажныхСлов.Вставить(стр.Слово,стр);
	КонецЦикла;
	
	КешВажныхСлов.Вставить("end_of_text_paragraf","end_of_text_paragraf");
	
	Для каждого слово из МассивСлов Цикл
		
		Если НЕ КешВажныхСлов.Получить(слово)=Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		стр_н = ТаблицаВажностиСлов.Добавить();
		стр_н.Слово = слово;
		стр_н.Важность = КоэффициентВажности;
		КешВажныхСлов.Вставить(слово,стр_н);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СтопСлова

&НаКлиенте
Процедура ЗагрузитьСтопСловаИзМакета(Команда)
	СтопСлова = ПолучитьМакетНаСервере("СтопСлова").ПолучитьТекст();
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьСтопФразыизМакета(Команда)
	СтопФразы = ПолучитьМакетНаСервере("СтопФразы").ПолучитьТекст();
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьФразыСинонимыИзМакета(Команда)
	ФразыСинонимы = ПолучитьМакетНаСервере("ФразыСинонимы").ПолучитьТекст();
КонецПроцедуры

&НаКлиенте
Функция Текст_УдалитьСтопСловаИзТекста(Знач Текст)
	
	ТекстБезСтопСлов = "";
	
	КешСтопСлов = новый Соответствие;
	ТекстСтопСлова = нрег(СтопСлова);
	ТекстСтопСлова = СтрЗаменить(ТекстСтопСлова," ",Символы.ПС);
	МассивСтопСлов = СтрРазделить(ТекстСтопСлова,Символы.ПС,Ложь);
	
	Для каждого стр из МассивСтопСлов Цикл
		стр = СокрЛП(стр);
		КешСтопСлов.Вставить(стр,стр);
	КонецЦикла;
	
	
	// разбиваем на слова
	МассивСловТекста = СтрРазделить(Текст," ", Ложь);
	
	// объединяем обратно                                     ,
	Для каждого слово из МассивСловТекста Цикл
		
		Если НЕ ЗначениеЗаполнено(слово) Тогда
			Продолжить;
		КонецЕсли;
		
		слово = СокрЛП(слово);
		
		Если НЕ КешСтопСлов.Получить(нрег(слово))=Неопределено Тогда
			Продолжить;
		КонецЕсли;	
		
		
		Если нрег(слово)="end_of_text_paragraf" Тогда
			ТекстБезСтопСлов = ТекстБезСтопСлов + Символы.ПС + слово+" " + Символы.ПС;
		Иначе
			ТекстБезСтопСлов = ТекстБезСтопСлов + слово+" ";
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТекстБезСтопСлов;
КонецФункции

&НаКлиенте
Функция Текст_УдалитьСтопФразыИзТекста(Знач Текст,Знач ИспНРег=Ложь)
	
	ТекстБезСтопФраз = Текст;
	
	Если ИспНРег=Истина Тогда
		ТекстСтопФразы = нрег(СтопФразы);
	Иначе 
		ТекстСтопФразы = СтопФразы;
	КонецЕсли;
	МассивСтопФраз = СтрРазделить(ТекстСтопФразы,Символы.ПС,Ложь);
	
	Для каждого фраза из МассивСтопФраз Цикл
		ТекстБезСтопФраз = СтрЗаменить(ТекстБезСтопФраз,фраза," ");
	КонецЦикла;
	
	Возврат ТекстБезСтопФраз;
КонецФункции


&НаКлиенте
Функция Текст_ОбработатьЗаменитьСинонимыИзТекста(Знач Текст,Знач ИспНРег=Ложь)
	
	ТекстБезСинонимовФраз = Текст;
	
	Если ИспНРег=Истина Тогда
		ТекстФразыСинонимы = нрег(ФразыСинонимы);
	Иначе 
		ТекстФразыСинонимы = ФразыСинонимы;
	КонецЕсли;
	МассивФразСинонимов = СтрРазделить(ТекстФразыСинонимы,Символы.ПС,Ложь);
	
	Для каждого фраза из МассивФразСинонимов Цикл
		Массив = СтрРазделить(фраза,"#",Ложь);
		Если Массив.Количество()<2 Тогда
			Продолжить;
		КонецЕсли;
		ТекстБезСинонимовФраз = СтрЗаменить(ТекстБезСинонимовФраз,СокрЛП(Массив[0]),СокрЛП(Массив[1]));
	КонецЦикла;
	
	Возврат ТекстБезСинонимовФраз;
КонецФункции


#КонецОбласти

#Область ФормируемБазис

&НаКлиенте
Процедура ПолучитьЧастотность(Команда)
	
	КешБазисныхСлов = новый Соответствие;
	ТекстДляРазбора = СтрЗаменить(ОбработанныйТекст,Символы.ПС," ");
	ТекстДляРазбора = СтрЗаменить(ТекстДляРазбора,нрег("END_OF_TEXT_PARAGRAF")," ");
	МассивСлов = СтрРазделить(ТекстДляРазбора," ",Ложь);
	//МассивСлов = ОбработатьМассивАлгоритмомСтеммингПриНеобходимости(МассивСлов);
	
	ЧастотаСлов = новый Соответствие;
	
	Для каждого стр из МассивСлов Цикл
		
		Если СтрДлина(стр)<3 Тогда
			Продолжить;
		КонецЕсли;
		
		Количество = ЧастотаСлов.Получить(стр);
		
		Если Количество=Неопределено Тогда
			ЧастотаСлов.Вставить(стр,1);
		Иначе
			ЧастотаСлов.Вставить(стр,Количество+1);
		КонецЕсли;
		
	КонецЦикла;
	
	БазисСлов.Очистить();
	Для каждого стр из ЧастотаСлов Цикл
		стр_н = БазисСлов.Добавить();
		стр_н.Слово = стр.Ключ;
		стр_н.Частота = стр.Значение;
		стр_н.guid = Строка(новый UUID());
	КонецЦикла;
	
	//Если Текст_ИспользоватьСтеммерПортера=Истина Тогда
	//	Для каждого стр из БазисСлов Цикл
	//		стр.Стеммер =  Модуль_СтеммерПортера.ПрименитьСтеммерПортера(стр.Слово);
	//		//СоответсвиеБазиса.Вставить(стр.Стеммер,Истина);
	//	КонецЦикла;	
	//КонецЕсли;
	
	БазисСлов.Сортировать("Частота Убыв");
	
	КоличествоСловБазис = БазисСлов.Количество();
	
	Элементы.Страницы.ТекущаяСтраница = Элементы.СтраницаБазис;

КонецПроцедуры


&НаКлиенте
Процедура УдалитьРедкиеЧастыеСлова(Команда)
	
	Если БазисСлов.Количество()=0 Тогда
		Сообщить("В таблице базис слов нет данных!");
		Возврат;
	КонецЕсли;
	
	Если БазисСлов.Количество()<3 Тогда
		Сообщить("В таблице базис слов мало данных, операция не имеет смыла!");
		Возврат;
	КонецЕсли;
	
	Если МаксимальнаяЧастотаПроцент<=МинимальнаяЧастотаПроцент Тогда
		Сообщить("Максимальная частота процент должна быть более минимальной!");
		Возврат;
	КонецЕсли;
	
	МинимальнаяЧастота = БазисСлов[0].Частота;
	МаксимальнаяЧастота = БазисСлов[0].Частота;
	
	// найдем слово с минимальной частотой и максимальной
	Для каждого стр из БазисСлов Цикл
		Если МинимальнаяЧастота>стр.Частота Тогда
			МинимальнаяЧастота=стр.Частота;
		КонецЕсли;
		Если МаксимальнаяЧастота<стр.Частота Тогда
			МаксимальнаяЧастота=стр.Частота;
		КонецЕсли;
	КонецЦикла;
	
	Длина = МаксимальнаяЧастота-МинимальнаяЧастота;
	МассивКУдалению = новый Массив;
	Для каждого стр из БазисСлов цикл
		Процент = ((стр.Частота-МинимальнаяЧастота)*100)/Длина;
		Если НЕ (Процент>МинимальнаяЧастотаПроцент И Процент<МаксимальнаяЧастотаПроцент) Тогда
			МассивКУдалению.Добавить(стр);
		КонецЕсли;
	КонецЦикла;
	
	Для каждого стр из МассивКУдалению Цикл
		БазисСлов.Удалить(стр);
	КонецЦикла;
	
	КоличествоСловБазис = БазисСлов.Количество();
КонецПроцедуры

&НаКлиенте
Процедура СформироватьТаблицуВекторов(Команда)
	
	КешДанныхСжатыхВекторов = новый Соответствие;
	КешСжатыхВекторов = новый Соответствие;
	КешРасчетныхДанных = новый Соответствие;
	КешБазисныхСлов = новый Соответствие;

	НачалоЗамера = ТекущаяДата();
	ТаблицаСвязиСловДокументов.Очистить();
	
	// вектор списка значений
	ВекторСловСписком = новый СписокЗначений;
	
	Для каждого Слово из БазисСлов Цикл
		Структура = новый Структура("Слово,Количество,КоличествоСлов,КоличествоДокументовЭтоСлово,TF,IDF,TFIDF,Значение",Слово.Слово,0,0,0,0,0,0,0);
		ВекторСловСписком.Добавить(Структура,Слово.Слово);
	КонецЦикла;
	// отсортируем
	ВекторСловСписком.СортироватьПоЗначению(НаправлениеСортировки.Возр);
	
	Для каждого Док из ТаблицаКорпусТекстов Цикл
		стр_н = ТаблицаСвязиСловДокументов.Добавить();
		стр_н.Документ = Док.НомерДокумента;
		стр_н.guid_Документ = Док.guid;
		стр_н.Вектор = ВекторСловСписком.Скопировать();
		Для каждого стр из стр_н.Вектор Цикл
			стр.Значение = новый Структура("Слово,Количество,КоличествоСлов,КоличествоДокументовЭтоСлово,TF,IDF,TFIDF,Значение",стр.Представление,0,0,0,0,0,0,0);
		КонецЦикла;
	КонецЦикла;
	Сообщить("Время (ЗаполнитьТаблицуСвязи): "+(ТекущаяДата()-НачалоЗамера));
	
КонецПроцедуры

&НаКлиенте
Процедура РассчитатьВекторноеПространство(Команда)
	
	НачалоЗамера = ТекущаяДата();	
	СоответсвиеБазисСлов = новый Соответствие;
	СоответсвиеСлов = новый Соответствие;
	КоличествоДокументов = ТаблицаКорпусТекстов.Количество();
	КоличествоСловВДокументе = новый Соответствие;
	КешВажностиСлов = новый Соответствие;
	КешТаблицыСвязей = новый Соответствие;
	КешВекторСловСписком = новый Соответствие;
	// TODO: требуется сброс векторов, иначе будут кривится данные - по крайней мере количество слов в текущем документе
	
	Для каждого стр из ТаблицаВажностиСлов Цикл
		КешВажностиСлов.Вставить(стр.Слово,стр);
	КонецЦикла;
	
	Для каждого стр из БазисСлов Цикл
		СоответсвиеБазисСлов.Вставить(стр.Слово,стр);
	КонецЦикла;
	
	Для каждого стр из ВекторСловСписком Цикл
		КешВекторСловСписком.Вставить(стр.Представление,стр);
	КонецЦикла;
	
	Для каждого стр из ТаблицаСвязиСловДокументов Цикл
		КешТаблицыСвязей.Вставить(стр.guid_Документ,стр);
	КонецЦикла;
	
	КешСловСоответствияВекторуСписка = новый Соответствие;
	
	Для каждого стр из ВекторСловСписком Цикл
		КешСловСоответствияВекторуСписка.Вставить(стр.Представление,ВекторСловСписком.Индекс(стр));
	КонецЦикла;
	
	// посчитаем количество слов в документе
	Для каждого Документ из ТаблицаКорпусТекстов Цикл
		
		МассивСлов = СтрРазделить(Документ.ОбработанныйТекст," ",Ложь);
		//МассивСлов = ОбработатьМассивАлгоритмомСтеммингПриНеобходимости(МассивСлов);
		Документ.КоличествоСлов = МассивСлов.Количество();
		ДокСвязи = КешТаблицыСвязей.Получить(Документ.guid);
		КешУжеВстретившихсяСлов = новый Соответствие;
		
		Для каждого Слово из МассивСлов Цикл
			Слово = СокрЛП(Слово);
			Индекс = КешСловСоответствияВекторуСписка.Получить(Слово);
			Если Индекс=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			стр = ДокСвязи.Вектор.Получить(Индекс).Значение;
			стр.Количество = стр.Количество+1;
			стр.КоличествоСлов = Документ.КоличествоСлов;
			
			// количество в документах
			Если КешУжеВстретившихсяСлов.Получить(Слово)=Неопределено Тогда
				КешУжеВстретившихсяСлов.Вставить(Слово,Истина);
				ВстречаетсяВДокументе = КоличествоСловВДокументе.Получить(Слово);
				Если ВстречаетсяВДокументе=Неопределено Тогда
					КоличествоСловВДокументе.Вставить(Слово,1);
				Иначе
					КоличествоСловВДокументе.Вставить(Слово,ВстречаетсяВДокументе+1);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	
	Для каждого стр из КоличествоСловВДокументе Цикл
		сл = СоответсвиеБазисСлов.Получить(стр.Ключ);
		Если сл=Неопределено Тогда
			Продолжить;
		КонецЕсли;
		сл.КоличествоДокументовЭтоСлово = стр.Значение;
		сл.IDF = Log10(КоличествоДокументов/сл.КоличествоДокументовЭтоСлово);
		век = КешВекторСловСписком.Получить(стр.Ключ);
		век.Значение.КоличествоДокументовЭтоСлово = стр.Значение;
	КонецЦикла;
	
	
	// посчитаем TF
	Для каждого Док из ТаблицаСвязиСловДокументов Цикл
		Для каждого эл из Док.Вектор Цикл
			стр = эл.Значение;
			ВстречаетсяВДокументе = КоличествоСловВДокументе.Получить(стр.Слово);
			Если НЕ ВстречаетсяВДокументе=Неопределено Тогда
				стр.КоличествоДокументовЭтоСлово = ВстречаетсяВДокументе;
				стр.IDF =  Log10(КоличествоДокументов/стр.КоличествоДокументовЭтоСлово);
			КонецЕсли;	
			Если стр.КоличествоСлов=0 ИЛИ стр.Количество=0 Тогда
				Продолжить;
			КонецЕсли;
			стрВажность = КешВажностиСлов.Получить(стр.Слово);
			Важность=1;
			Если НЕ стрВажность=Неопределено Тогда
				Важность = стрВажность.Важность;
			КонецЕсли;
			стр.TF=Важность*стр.Количество/стр.КоличествоСлов;
			стр.TFIDF = стр.TF*стр.IDF;
			стр.Значение = стр.TFIDF;
		КонецЦикла;
	КонецЦикла;

	Сообщить("Время (ОпределитьДанныеСвязи): "+(ТекущаяДата()-НачалоЗамера));
	
КонецПроцедуры

&НаКлиенте
Процедура РассчитатьВекторноеПространствоПоКлассификатору(Команда)
	
	НачалоЗамера = ТекущаяДата();	
	СоответсвиеБазисСлов = новый Соответствие;
	СоответсвиеСлов = новый Соответствие;
	КоличествоДокументов = ТаблицаКлассификатор.Количество();
	//КоличествоСловВДокументе = новый Соответствие;
	КешВажностиСлов = новый Соответствие;
	КешТаблицыСвязей = новый Соответствие;
	КешВекторСловСписком = новый Соответствие;
	
	
	Для каждого стр из ТаблицаВажностиСлов Цикл
		КешВажностиСлов.Вставить(стр.Слово,стр);
	КонецЦикла;
	
	Для каждого стр из БазисСлов Цикл
		СоответсвиеБазисСлов.Вставить(стр.Слово,стр);
	КонецЦикла;
	
	Для каждого стр из ВекторСловСписком Цикл
		КешВекторСловСписком.Вставить(стр.Представление,стр);
	КонецЦикла;
	
	Для каждого стр из ТаблицаСвязиСловДокументов Цикл
		КешТаблицыСвязей.Вставить(стр.guid_Документ,стр);
	КонецЦикла;
	
	КешСловСоответствияВекторуСписка = новый Соответствие;
	
	Для каждого стр из ВекторСловСписком Цикл
		КешСловСоответствияВекторуСписка.Вставить(стр.Представление,ВекторСловСписком.Индекс(стр));
	КонецЦикла;
	
	// посчитаем количество слов в документе
	Для каждого Документ из ТаблицаКорпусТекстов Цикл
		
		МассивСлов = СтрРазделить(Документ.ОбработанныйТекст," ",Ложь);
		//МассивСлов = ОбработатьМассивАлгоритмомСтеммингПриНеобходимости(МассивСлов);
		Документ.КоличествоСлов = МассивСлов.Количество();
		ДокСвязи = КешТаблицыСвязей.Получить(Документ.guid);
		
		Для каждого Слово из МассивСлов Цикл
			Слово = СокрЛП(Слово);
			Индекс = КешСловСоответствияВекторуСписка.Получить(Слово);
			Если Индекс=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			стр = ДокСвязи.Вектор.Получить(Индекс).Значение;
			стр.Количество = стр.Количество+1;
			стр.КоличествоСлов = Документ.КоличествоСлов;
			
			//// количество в документах
			//ВстречаетсяВДокументе = КоличествоСловВДокументе.Получить(Слово);
			//Если ВстречаетсяВДокументе=Неопределено Тогда
			//	КоличествоСловВДокументе.Вставить(Слово,1);
			//Иначе
			//	КоличествоСловВДокументе.Вставить(Слово,ВстречаетсяВДокументе+1);
			//КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	
	//Для каждого стр из КоличествоСловВДокументе Цикл
	//	сл = СоответсвиеБазисСлов.Получить(стр.Ключ);
	//	Если сл=Неопределено Тогда
	//		Продолжить;
	//	КонецЕсли;
	//	сл.КоличествоДокументовЭтоСлово = стр.Значение;
	//	век = КешВекторСловСписком.Получить(стр.Ключ);
	//	век.Значение.КоличествоДокументовЭтоСлово = стр.Значение;
	//КонецЦикла;
	
	
	// посчитаем TF
	Для каждого Док из ТаблицаСвязиСловДокументов Цикл
		Для каждого эл из Док.Вектор Цикл
			стр = эл.Значение;
			базис_слово = СоответсвиеБазисСлов.Получить(стр.Слово);
			стр.КоличествоДокументовЭтоСлово = базис_слово.КоличествоДокументовЭтоСлово;
			стр.IDF =  базис_слово.IDF;
			Если стр.КоличествоСлов=0 ИЛИ стр.Количество=0 Тогда
				Продолжить;
			КонецЕсли;
			стрВажность = КешВажностиСлов.Получить(стр.Слово);
			Важность=1;
			Если НЕ стрВажность=Неопределено Тогда
				Важность = стрВажность.Важность;
			КонецЕсли;
			стр.TF=Важность*стр.Количество/стр.КоличествоСлов;
			стр.TFIDF = стр.TF*стр.IDF;
			стр.Значение = стр.TFIDF;
		КонецЦикла;
	КонецЦикла;

	Сообщить("Время (ОпределитьДанныеСвязиПоКлассификатору): "+(ТекущаяДата()-НачалоЗамера));

КонецПроцедуры



#КонецОбласти

&НаСервере
Процедура УдалитьДублиОбработанныеДокументовНаСервере()
	
	МассивКУдалению = новый Массив;
	КешХешТекстов = новый Соответствие;
	ш=1;
	Для каждого стр из ТаблицаКорпусТекстов Цикл
		
		// удалим пробелы
		ТекстПроверки = СтрЗаменить(стр.ОбработанныйТекст," ","");
		
		ПотокПамять = Новый ПотокВПамяти;
    	Писатель = Новый ЗаписьДанных(ПотокПамять, КодировкаТекста.UTF8,,"","");
    	Писатель.ЗаписатьСтроку(ТекстПроверки, КодировкаТекста.UTF8);
    	Писатель.Закрыть();
		Хеш = новый ХешированиеДанных(ХешФункция.MD5);
		Хеш.Добавить(ПотокПамять.ЗакрытьИПолучитьДвоичныеДанные());  
		Если НЕ КешХешТекстов.Получить(Хеш.ХешСумма)=Неопределено Тогда
			МассивКУдалению.Добавить(стр);
			Продолжить;
		КонецЕсли;
		
		КешХешТекстов.Вставить(Хеш.ХешСумма,Истина);		
		стр.НомерДокумента = ш;
		
		ш=ш+1;
	КонецЦикла;
	
	Для каждого стр из МассивКУдалению Цикл
		ТаблицаКорпусТекстов.Удалить(стр);
	КонецЦикла;
	
	РазмерКорпуса = ТаблицаКорпусТекстов.Количество();
КонецПроцедуры

&НаКлиенте
Процедура УдалитьДублиОбработанныеДокументов(Команда)
	УдалитьДублиОбработанныеДокументовНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ОбработатьТексты(Команда)
	
	ДанныеТекст = СтрЗаменить(ОбработанныйТекст,нрег("END_OF_TEXT_PARAGRAF"),Символ(18));
	МассивТекстов = СтрРазделить(ДанныеТекст,Символ(18),Истина);
	
	ш=0;
	Для ш=0 по МассивТекстов.ВГраница()-1 Цикл
		ТаблицаКорпусТекстов[ш].ОбработанныйТекст = СтрЗаменить(МассивТекстов[ш],Символы.ПС," ");
	КонецЦикла;

КонецПроцедуры

&НаКлиенте
Процедура ТаблицаКорпусТекстовПриАктивизацииСтроки(Элемент)
	ТекущиеДанные = Элементы.ТаблицаКорпусТекстов.ТекущиеДанные;
	Если ТекущиеДанные=Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТекстКорпуса = ТекущиеДанные.Текст;	
	ОбработанныйТекстКорпуса = ТекущиеДанные.ОбработанныйТекст;	
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаСвязиСловДокументовПриАктивизацииСтроки(Элемент)
	ТекущиеДанные = Элементы.ТаблицаСвязиСловДокументов.ТекущиеДанные;
	Если ТекущиеДанные= Неопределено Тогда
		возврат;
	КонецЕсли;
	
	ПредставлениеВектора.Очистить();
	Для каждого стр из ТекущиеДанные.Вектор Цикл
		стр_н = ПредставлениеВектора.Добавить();
		ЗаполнитьЗначенияСвойств(стр_н,стр.Значение);
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Процедура ПоискБлизкихДокументов(Команда)
	ПоискПоДокументам(СтрокаЗапроса);
КонецПроцедуры


&НаКлиенте
Процедура ПоискБлизкихДокументовПоКлассификатору(Команда)
	ТекущиеДанные = Элементы.ТаблицаКлассификатор1.ТекущиеДанные;
	Если ТекущиеДанные=Неопределено Тогда
		Возврат;
	КонецЕсли;
	ПоискПоДокументам(ТекущиеДанные.Текст);
КонецПроцедуры

&НаКлиенте
Процедура ПоискПоДокументам(ТекстЗапроса)
	НачалоЗамера = ТекущаяДата();
	
	// 1. Разберем слово
	ОбработаннаяСтрокаЗапроса = ОбработатьТекстДанных(ТекстЗапроса);
	// 2. Составим вектор
	ОбработаннаяСтрокаЗапроса = СтрЗаменить(ОбработаннаяСтрокаЗапроса,Символы.ПС," ");
	ОбработаннаяСтрокаЗапроса = УдалитьСловаНеВходящиеВБазис(ОбработаннаяСтрокаЗапроса);
	МассивСлов = СтрРазделить(ОбработаннаяСтрокаЗапроса," ",Ложь);
	//МассивСлов = ОбработатьМассивАлгоритмомСтеммингПриНеобходимости(МассивСлов);
	
	Если Текст_ИспользоватьСтеммерПортера=Истина Тогда
		ОбработаннаяСтрокаЗапроса = СтрСоединить(МассивСлов," ");
	КонецЕсли;
	
	ВекторЗапроса = новый Массив;
	КоличествоСловЗапроса = МассивСлов.Количество();
	КоличествоДокументов = ТаблицаКорпусТекстов.Количество();
	Если КоличествоДокументов=0 Тогда
		КоличествоДокументов=1;
	КонецЕсли;
	КешВажностиСлов = новый Соответствие;
	
	Для каждого стр из ТаблицаВажностиСлов Цикл
		КешВажностиСлов.Вставить(стр.Слово,стр);
	КонецЦикла;
	
	
	Для каждого эл из ВекторСловСписком Цикл
		стр = эл.Значение;
		
		Точка = новый Структура("Слово,Количество,КоличествоСлов,TF,IDF,TFIDF,Значение",стр.Слово,0,0,0,0,0,0);
		
		КоличествоВхождений = СтрЧислоВхождений(" "+ОбработаннаяСтрокаЗапроса+" "," "+стр.Слово+" ");		
		
		Если КоличествоВхождений>0 Тогда
			
			стрВажность = КешВажностиСлов.Получить(стр.Слово);
			Важность=1;
			Если НЕ стрВажность=Неопределено Тогда
				Важность = стрВажность.Важность;
			КонецЕсли;
			
			Точка.Количество = КоличествоВхождений;
			Точка.TF = Важность*КоличествоВхождений/КоличествоСловЗапроса;			
			Если стр.КоличествоДокументовЭтоСлово=0 Тогда
				стр.КоличествоДокументовЭтоСлово=1;
			КонецЕсли;			
			Точка.IDF =  Log10(КоличествоДокументов/стр.КоличествоДокументовЭтоСлово);
			Точка.TFIDF = Точка.IDF*Точка.TF;
			Точка.Значение = Точка.TFIDF;
		КонецЕсли;
		
		ВекторЗапроса.Добавить(Точка);
		
	КонецЦикла;
	
	// 3. Вычислим косинусы
	КешДокументов = новый Соответствие;
	Для каждого стр из ТаблицаКорпусТекстов Цикл
		КешДокументов.Вставить(стр.guid,стр);
	КонецЦикла;
	
	ТаблицаРезультатаБлизости.Очистить();
	Для каждого стр из ТаблицаСвязиСловДокументов Цикл
		Косинус = ПолучитьКосинусВекторов(ВекторЗапроса,стр.Вектор);
		стр_н = ТаблицаРезультатаБлизости.Добавить();
		стр_н.Косинус = Косинус;
		стр_н.guid = стр.guid_Документ;
		док = КешДокументов.Получить(стр.guid_Документ);
		стр_н.Документ = док.НомерДокумента;
		стр_н.Текст = док.Текст;
		стр_н.ОбработанныйТекст = док.ОбработанныйТекст;
	КонецЦикла;
	
//	ТаблицаРезультатаБлизости.Сортировать("Косинус Убыв");
	СортировкаТаблицы();
	
	Сообщить("Завершено (ПоискПоДокументам): "+(ТекущаяДата()-НачалоЗамера));
КонецПроцедуры	

// Функция - Скопировать вектор
//
// Параметры:
//  вхВектор1	 - список значений	 - вектор для копирвоания
// 
// Возвращаемое значение:
//  список значений - новый вектор
//
&Наклиенте
Функция СкопироватьВектор(вхВектор1)
	
	нВектор = вхВектор1.Скопировать();
	Для ш=0 по нВектор.Количество()-1 Цикл
		нВектор[ш].Значение = новый Структура("Слово,Количество,КоличествоСлов,КоличествоДокументовЭтоСлово,TF,IDF,TFIDF,Значение",нВектор[ш].Представление,0,0,0,0,0,0,0);
		ЗаполнитьЗначенияСвойств(нВектор[ш].Значение,вхВектор1[ш].Значение);
	КонецЦикла;
	
	Возврат нВектор;
КонецФункции

// Процедура - Добавить вектор
//
// Параметры:
//  исхВектор1	 - список значнеий - исходный вектор результат
//  добВектор2	 - список значнеий - добавляемый вектор
//
&НаКлиенте
Процедура ДобавитьВектор(исхВектор,добВектор)
	Для ш = 0 по исхВектор.Количество()-1 Цикл
		исхВектор[ш].Значение.Значение = исхВектор[ш].Значение.Значение+добВектор[ш].Значение.Значение;
		исхВектор[ш].Значение.Значение = исхВектор[ш].Значение.TF+добВектор[ш].Значение.TF;
		исхВектор[ш].Значение.Значение = исхВектор[ш].Значение.TFIDF+добВектор[ш].Значение.TFIDF;
	КонецЦикла;
КонецПроцедуры

&Наклиенте
Функция СложитьВектораРезНовыйВектор(вхВектор1,вхВектор2)
	
	// копия и сложение
	нВектор = вхВектор1.Скопировать();
	Для ш=0 по нВектор.Количество()-1 Цикл
		стр = нВектор[ш];
		стр.Значение = новый Структура("Слово,Количество,КоличествоСлов,КоличествоДокументовЭтоСлово,TF,IDF,TFIDF,Значение",стр.Представление,0,0,0,0,0,0,0);
		стр1 = вхВектор1[ш];
		стр2 = вхВектор2[ш];
		ЗаполнитьЗначенияСвойств(стр.Значение,стр1.Значение);
		стр.Значение.Значение = стр1.Значение.Значение+стр2.Значение.Значение;
		стр.Значение.Значение = стр1.Значение.TF+стр2.Значение.TF;
		стр.Значение.Значение = стр1.Значение.TFIDF+стр2.Значение.TFIDF;
	КонецЦикла;
	
	Возврат нВектор;
КонецФункции


// Функция - Получить косинус между двумя векторами
//
// Параметры:
//  вхВектор1	 - список значений/массив - первый вектор
//  вхВектор2	 - список значений/массив - второй вектор
// 
// Возвращаемое значение:
// число  - результат перемножения векторов, если у одного (обоих) векторов длина равно 0 (нулевой вектор), то резултат будет -999999999.
//
&НаКлиенте
Функция ПолучитьКосинусВекторов(вхВектор1, вхВектор2)
	
	Косинус = 0;
	Ключ1 = Неопределено;
	Ключ2 = Неопределено;
	Если ТипЗнч(вхВектор1)=Тип("СписокЗначений") Тогда
		Ключ1 = вхВектор1;
		Вектор1 = КешДанныхСжатыхВекторов.Получить(Ключ1);
		Если Вектор1=Неопределено Тогда
			Вектор1 = вхВектор1.ВыгрузитьЗначения();
			КешДанныхСжатыхВекторов.Вставить(Ключ1,Вектор1);
		КонецЕсли;
	Иначе
		Вектор1 = вхВектор1;
	КонецЕсли;
	Если ТипЗнч(вхВектор2)=Тип("СписокЗначений") Тогда
		Ключ2 = вхВектор2;
		Вектор2 = КешДанныхСжатыхВекторов.Получить(Ключ2);
		Если Вектор2=Неопределено Тогда
			Вектор2 = вхВектор2.ВыгрузитьЗначения();
			КешДанныхСжатыхВекторов.Вставить(Ключ2,Вектор2);
		КонецЕсли;
	Иначе
		Вектор2 = вхВектор2;
	КонецЕсли;
	
	ДлинаВектор1 = ПолучитьДлинуВектора(Вектор1,Ключ1);
	ДлинаВектор2 = ПолучитьДлинуВектора(Вектор2,Ключ2);
	
	Если ДлинаВектор1=0 ИЛИ ДлинаВектор2=0 Тогда
		Возврат -999999999;
	КонецЕсли;
	
	ПроизведениеВекторов = 0;
	
	// оптимизация
	Если Истина Тогда
		СжатыйВектор1 = КешСжатыхВекторов.Получить(Ключ1);
		Если СжатыйВектор1=Неопределено Тогда
			СжатыйВектор1 = СжатьВектор(Вектор1,Ключ1);
			Если НЕ Ключ1=Неопределено Тогда
				КешСжатыхВекторов.Вставить(Ключ1,СжатыйВектор1);
			КонецЕсли;
		КонецЕсли;
		СжатыйВектор2 = КешСжатыхВекторов.Получить(Ключ2);
		Если СжатыйВектор2=Неопределено Тогда
			СжатыйВектор2 = СжатьВектор(Вектор2,Ключ2);
			Если НЕ Ключ2=Неопределено Тогда
				КешСжатыхВекторов.Вставить(Ключ2,СжатыйВектор2);
			КонецЕсли;
		КонецЕсли;
		
		БольшийВектор = Неопределено;
		МенишийВектор = Неопределено;
		Если СжатыйВектор1.Количество()>СжатыйВектор2.Количество() Тогда
			МенишийВектор=СжатыйВектор2;
			БольшийВектор=СжатыйВектор1;
		Иначе
			МенишийВектор=СжатыйВектор1;
			БольшийВектор=СжатыйВектор2;
		КонецЕсли;
		
		Для каждого ш из МенишийВектор Цикл
			ж = БольшийВектор.Получить(ш.Ключ);
			Если ж=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ПроизведениеВекторов = ПроизведениеВекторов + ш.Значение*ж;
		КонецЦикла;
		
	Иначе		
		Для ш=0 по Вектор1.Количество()-1 Цикл
			ПроизведениеВекторов = ПроизведениеВекторов+Вектор1[ш].Значение*Вектор2[ш].Значение;
		КонецЦикла;
	КонецЕсли;
	
	Косинус = Окр(ПроизведениеВекторов/(ДлинаВектор1*ДлинаВектор2),5,РежимОкругления.Окр15как20);
	
	Возврат Косинус;
	
КонецФункции

&НаКлиенте
Функция СжатьВектор(Вектор,Ключ)
	СжатыйВекторРезультат = новый Соответствие;
	
	Для ш=0 по Вектор.Количество()-1 Цикл
		Если Вектор[ш].Значение=0 Тогда
			Продолжить;
		КонецЕсли;
		СжатыйВекторРезультат.Вставить(ш,Вектор[ш].Значение);
	КонецЦикла;
	
	Возврат СжатыйВекторРезультат;
КонецФункции

&НаКлиенте
Функция ПолучитьДлинуВектора(Знач Вектор1, Знач Ключ=Неопределено)
	
	ДлинаВектора = Неопределено;
	Если НЕ Ключ=Неопределено Тогда
		ДлинаВектора = КешРасчетныхДанных.Получить(Ключ);
	КонецЕсли;
	
	Если ДлинаВектора=Неопределено Тогда	
		ДлинаВектора= 0;
		Для каждого стр из Вектор1 Цикл
			ДлинаВектора = ДлинаВектора+стр.Значение*стр.Значение;
		КонецЦикла;
		ДлинаВектора = Окр(ДлинаВектора,5,РежимОкругления.Окр15как20);
		Если НЕ Ключ=Неопределено Тогда
			КешРасчетныхДанных.Вставить(Ключ,ДлинаВектора);
		КонецЕсли;
	Конецесли;
	
	Возврат  Sqrt(ДлинаВектора);
	
КонецФункции

&НаКлиенте
Функция ОбработатьМассивАлгоритмомСтеммингПриНеобходимости(МассивСлов)
	
	// стеммер
	Если НЕ Текст_ИспользоватьСтеммерПортера Тогда
		Возврат МассивСлов;
	КонецЕсли;		
	
	ОбработанныйМассивСлов = новый Массив;
	
	МассивКУдалению = новый Массив;
	Для каждого стр из МассивСлов Цикл
		//Стеммер = КешСтеммераПортера.Получить(стр);
		//Если Стеммер=Неопределено Тогда
		//	Стеммер = Модуль_СтеммерПортера.ПрименитьСтеммерПортера(стр);
		//	КешСтеммераПортера.Вставить(стр,Стеммер);
		//КонецЕсли;	
		Стеммер = СтеммерПортераКлиентСерверПовтИсп.ПрименитьСтеммерПортера(стр);
		ОбработанныйМассивСлов.Добавить(Стеммер);
	КонецЦикла;
	
	Возврат ОбработанныйМассивСлов;

КонецФункции

&НаКлиенте
Функция ОбработатьСловоАлгоритмомСтеммингПриНеобходимости(Слово)
	
	// стеммер
	Если НЕ Текст_ИспользоватьСтеммерПортера Тогда
		Возврат Слово;
	КонецЕсли;		
	
	//Стеммер = КешСтеммераПортера.Получить(Слово);
	//Если Стеммер=Неопределено Тогда
	//	Стеммер = Модуль_СтеммерПортера.ПрименитьСтеммерПортера(Слово);
	//	КешСтеммераПортера.Вставить(Слово,Стеммер);
	//КонецЕсли;	
	Стеммер = СтеммерПортераКлиентСерверПовтИсп.ПрименитьСтеммерПортера(Слово);
	
	Возврат Стеммер;

КонецФункции

&НаКлиенте
Процедура СортировкаТаблицы()
	
	ЕстьСдвиги = Истина;
	
	Пока ЕстьСдвиги=Истина Цикл
		ЕстьСдвиги = Ложь;
		Для ш =0 по ТаблицаРезультатаБлизости.Количество()-2 Цикл
			
			Если ТаблицаРезультатаБлизости[ш].Косинус<ТаблицаРезультатаБлизости[ш+1].Косинус Тогда
				ТаблицаРезультатаБлизости.Сдвинуть(ш,1);
				ЕстьСдвиги = Истина;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры

&НаКлиенте
Процедура ТаблицаРезультатаБлизостиПриАктивизацииСтроки(Элемент)
	ТекущиеДанные = Элементы.ТаблицаРезультатаБлизости.ТекущиеДанные;
	
	Если ТекущиеДанные=Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТекстДокумента = ТекущиеДанные.Текст;
	ОбработанныйТекстДокумента = ТекущиеДанные.ОбработанныйТекст;
КонецПроцедуры

#Область Похожесть

&НаКлиенте
Процедура ЗаполнитьТаблицуЦветов(Команда)
	ТаблицаЦветов.Очистить();
	Для ш=0 по ТаблицаКорпусТекстов.Количество()-1 Цикл
		стр = ТаблицаКорпусТекстов[ш];
		стр_н = ТаблицаЦветов.Добавить();
		стр_н.Цвет = "";
		ЗаполнитьЗначенияСвойств(стр_н,стр);
		стр_н.КоличествоСовпашихЦветов = 1;
		стр_н.КоличествоВГруппе = 1;
	КонецЦикла;
КонецПроцедуры  

&НаКлиенте
Процедура ПолучитьПохожесть(Команда)
	
	НачалоЗамера = ТекущаяДата();
	
	КоличествоЦветов = 0;
	
	КешОбработанныхЦветов = новый Соответствие;
	КешВекторовДокументов = новый Соответствие;
	
	// формируем кеш векторов
	Для каждого стр из ТаблицаСвязиСловДокументов Цикл
		КешВекторовДокументов.Вставить(стр.guid_Документ,стр);
	КонецЦикла;
	
	Для ш=0 по ТаблицаЦветов.Количество()-1 Цикл
		стр = ТаблицаЦветов[ш];
		// уже есть цвет
		Если НЕ КешОбработанныхЦветов.Получить(стр.guid)=Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Цвет = ПолучитьНовыйЦвет();
		//стр_н = ТаблицаЦветов.Добавить();
		стр_н = ТаблицаЦветов[ш];
		стр_н.Цвет = Цвет;
		//ЗаполнитьЗначенияСвойств(стр_н,стр);
		КешОбработанныхЦветов.Вставить(стр.guid,Цвет);
		// обходим только новые
		Для ф = ш+1 по ТаблицаЦветов.Количество()-1 Цикл
			сосед = ТаблицаЦветов[ф];
			Если НЕ КешОбработанныхЦветов.Получить(сосед.guid)=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			// получим косинус
			СвойстваДокумента1 = КешВекторовДокументов.Получить(стр.guid);
			СвойстваДокумента2 = КешВекторовДокументов.Получить(сосед.guid);
			
			// какойто косяк, такого быть не должно
			Если СвойстваДокумента1=Неопределено ИЛИ СвойстваДокумента2=Неопределено Тогда
				Сообщить("В кеше не найдены вектора! Возможно стоит пересчитать!");
				Продолжить;
			КонецЕсли;
			
			Косинус = ПолучитьКосинусВекторов(СвойстваДокумента1.Вектор,СвойстваДокумента2.Вектор);
			Если Косинус>=ГраницаБлизостиКосинус Тогда
				//стр_н = ТаблицаЦветов.Добавить();
				стр_н = ТаблицаЦветов[ф];
				стр_н.Цвет = Цвет;
				//ЗаполнитьЗначенияСвойств(стр_н,сосед);
				КешОбработанныхЦветов.Вставить(сосед.guid,Цвет);
				стр_н.Косинус = Косинус;
			КонецЕсли;				
		КонецЦикла;
	КонецЦикла;
	
	ОпределитьКолчиествоВГруппеЦветов();
	
	Сообщить("Завершено (ПолучитьПохожестьКосинус): "+(ТекущаяДата()-НачалоЗамера));

КонецПроцедуры

&НаКлиенте
Процедура ПолучитьПохожестьШиглами(Команда)
	НачалоЗамера = ТекущаяДата();
	
	КоличествоЦветов = 0;
	КешОбработанныхЦветов = новый Соответствие;
	КешВекторовДокументов = новый Соответствие;
	
	// формируем кеш векторов
	Для каждого стр из ТаблицаСвязиСловДокументов Цикл
		КешВекторовДокументов.Вставить(стр.guid_Документ,стр);
	КонецЦикла;

	
	Для ш=0 по ТаблицаЦветов.Количество()-1 Цикл
		стр = ТаблицаКорпусТекстов[ш];
		// уже есть цвет
		Если НЕ КешОбработанныхЦветов.Получить(стр.guid)=Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Цвет = ПолучитьНовыйЦвет();
		//стр_н = ТаблицаЦветов.Добавить();
		стр_н = ТаблицаЦветов[ш];
		стр_н.Цвет = Цвет;
		//ЗаполнитьЗначенияСвойств(стр_н,стр);
		КешОбработанныхЦветов.Вставить(стр.guid,Цвет);
		// обходим только новые
		Для ф = ш+1 по ТаблицаЦветов.Количество()-1 Цикл
			сосед = ТаблицаЦветов[ф];
			Если НЕ КешОбработанныхЦветов.Получить(сосед.guid)=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Похожесть = ПохожестьТекстовМетодШинглов(стр.ОбработанныйТекст,сосед.ОбработанныйТекст,стр.guid,сосед.guid);
			
			Если Похожесть>=ГраницаБлизостиШинглы Тогда
				//стр_н = ТаблицаЦветов.Добавить();
				стр_н = ТаблицаЦветов[ф];
				стр_н.Цвет = Цвет;
				//ЗаполнитьЗначенияСвойств(стр_н,сосед);
				КешОбработанныхЦветов.Вставить(сосед.guid,Цвет);
				стр_н.Похожесть = Похожесть;
			КонецЕсли;				
		КонецЦикла;
	КонецЦикла;
	
	ОпределитьКолчиествоВГруппеЦветов();
	
	Сообщить("Завершено (ПолучитьПохожестьШиглами): "+(ТекущаяДата()-НачалоЗамера));

КонецПроцедуры

&НаКлиенте
Процедура ОпределитьКолчиествоВГруппеЦветов()
	
	// определим колчиество в группе
	КоличествоСовпашихЦветов = новый Соответствие;
	Для каждого стр из ТаблицаЦветов Цикл
		Количество = КоличествоСовпашихЦветов.Получить(стр.Цвет);
		Если Количество = Неопределено Тогда
			Количество = 0;
		КонецЕсли;
		КоличествоСовпашихЦветов.Вставить(стр.Цвет,Количество+1);
	КонецЦикла;
	
	Для каждого стр из ТаблицаЦветов Цикл
		стр.КоличествоСовпашихЦветов = КоличествоСовпашихЦветов.Получить(стр.Цвет);
	КонецЦикла;

КонецПроцедуры

&НаКлиенте
Процедура УдалитьСловаВнеБазиса(Команда)
	
	НачалоЗамера = ТекущаяДата();
	//
	//Если Текст_ИспользоватьСтеммерПортера=Истина Тогда
	//	Сообщить("Не доступно при использовании стеммера!");
	//	Возврат;
	//КонецЕсли;
	
	Для каждого стр из ТаблицаЦветов Цикл
		стр.ОбработанныйТекст = УдалитьСловаНеВходящиеВБазис(стр.ОбработанныйТекст);
	КонецЦикла;
	
	Сообщить("Завершено (УдалитьСловаВнеБазиса): "+(ТекущаяДата()-НачалоЗамера));
	
КонецПроцедуры

&НаКлиенте
Функция УдалитьСловаНеВходящиеВБазис(Текст)
	
	Если КешБазисныхСлов=Неопределено или КешБазисныхСлов.Количество()=0 Тогда
		КешБазисныхСлов = новый Соответствие;
		
		Для каждого стр из БазисСлов Цикл
			КешБазисныхСлов.Вставить(стр.Слово,Истина);
		КонецЦикла;
	КонецЕсли;
	
	ТекстТолькоБазовыеСлова = "";
	МассивВерныхСлов = новый Массив;
	
	МассивСлов = СтрРазделить(Текст," "+Символы.ПС,Ложь);
	Для каждого стр из МассивСлов Цикл
		слово = СокрЛП(стр);
		Если КешБазисныхСлов.Получить(слово)=Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивВерныхСлов.Добавить(слово);
	КонецЦикла;
	
	Возврат СтрСоединить(МассивВерныхСлов," ");
КонецФункции

&НаКлиенте
Функция УдалитьСловаПоМассиву(Текст,МассивСлов)
	
	ЛокКешБазисныхСлов = новый Соответствие;
	
	Для каждого стр из МассивСлов Цикл
		ЛокКешБазисныхСлов.Вставить(стр,Истина);
	КонецЦикла;
	
	ТекстТолькоБазовыеСлова = "";
	МассивВерныхСлов = новый Массив;
	
	МассивСлов = СтрРазделить(Текст," "+Символы.ПС,Ложь);
	Для каждого стр из МассивСлов Цикл
		слово = СокрЛП(стр);
		Если НЕ ЛокКешБазисныхСлов.Получить(слово)=Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивВерныхСлов.Добавить(слово);
	КонецЦикла;
	
	Возврат СтрСоединить(МассивВерныхСлов," ");
КонецФункции

&НаКлиенте
Функция ПолучитьНовыйЦвет()
	
	Цвет = "";
	Если МассивЦветов.ВГраница()>=КоличествоЦветов Тогда
		Цвет = МассивЦветов[КоличествоЦветов];
	Иначе
		Цвет = ""+КоличествоЦветов+ " цвет ";
	КонецЕсли;		
	
	КоличествоЦветов = КоличествоЦветов+1;
	
	Возврат Цвет;
КонецФункции

&НаКлиенте
Процедура ОпределитьЛишниеСлова(Команда)
	
	КешЦветовыхГрупп = новый Соответствие;
	
	// определим группы
	Для каждого стр из ТаблицаЦветов Цикл
		МассивГруппы = КешЦветовыхГрупп.Получить(стр.Цвет);
		Если МассивГруппы=Неопределено Тогда
			МассивГруппы = новый Массив;
			КешЦветовыхГрупп.Вставить(стр.Цвет,МассивГруппы);
		КонецЕсли;		
		МассивГруппы.Добавить(стр);
	КонецЦикла;
	
	// проставим количество в группе
	Для каждого группа из КешЦветовыхГрупп Цикл
		Для каждого эл из группа.Значение Цикл
			эл.КоличествоСовпашихЦветов = группа.Значение.Количество();
		КонецЦикла;
	КонецЦикла;
	
	// ищем в группах лишние слова
	Для каждого МассивГруппы из КешЦветовыхГрупп Цикл
		
		ЧастотаСловВГруппе = новый Соответствие;
		КоличествоСовпашихЦветов = 0;
		Для каждого стр из МассивГруппы.Значение Цикл
			КоличествоСовпашихЦветов = стр.КоличествоСовпашихЦветов;
			// найдем слова и внутрненню частоту группы
			МассивСтр = СтрРазделить(стр.ОбработанныйТекст," ",Ложь);
			Для каждого слово из МассивСтр Цикл
				Частота = ЧастотаСловВГруппе.Получить(слово);
				Если Частота=Неопределено Тогда
					Частота = 1;
				Иначе
					Частота = Частота+1;
				КонецЕсли;
				ЧастотаСловВГруппе.Вставить(слово,Частота);
			КонецЦикла;		
		КонецЦикла;
		
		// Теперь удалим, которые встречаются менее 10%
		Если ЧастотаСловВГруппе.Количество()>2 Тогда
			МассивЛишнихСлов = новый Массив;
			Для каждого эл из ЧастотаСловВГруппе Цикл
				Если эл.Значение*100/КоличествоСовпашихЦветов <10 Тогда
					МассивЛишнихСлов.Добавить(эл.Ключ);
				КонецЕсли;
			КонецЦикла;
			// запуск процедуры удаления для группы
			Если МассивЛишнихСлов.Количество()>0  Тогда
				Для каждого стр из МассивГруппы.Значение Цикл
					стр.ОбработанныйТекст = УдалитьСловаПоМассиву(стр.ОбработанныйТекст,МассивЛишнихСлов);
				КонецЦикла;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры


#КонецОбласти

#Область ДобавлениеОбновлениеКлассификатора

&НаКлиенте
Функция Тема_ПроверитьНаНаличиеПодобных(Текст)
	Похожесть = 0;
	
	Для каждого стр из ТаблицаКлассификатор Цикл
		врПохожесть = ПохожестьТекстовМетодШинглов(Текст,стр.ОбработанныйТекст);
		Если врПохожесть>Похожесть Тогда
			Похожесть=врПохожесть;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Похожесть;
КонецФункции

&НаКлиенте
Процедура Тема_ДобавитьТему(Команда)
	
	ВыделенныеСтроки = Элементы.ТаблицаЦветов.ВыделенныеСтроки;
	
	Если ВыделенныеСтроки=Неопределено или ВыделенныеСтроки.Количество()=0 Тогда
		Возврат;
	КонецЕсли;
	
	Для каждого стр из ВыделенныеСтроки Цикл
		строка = ЭтаФорма.ТаблицаЦветов.НайтиПоИдентификатору(стр);
		
		Похожесть = Тема_ПроверитьНаНаличиеПодобных(строка.ОбработанныйТекст);
		
		Если Похожесть>80 Тогда 
			Сообщить("Добавляемый текст "+строка.НомерДокумента+" уже есть в списке с вероятностью более "+Похожесть+"%. Отказ добавления!");
			Продолжить;
		КонецЕсли;
		
		Если Похожесть>40 Тогда
			Сообщить("Добавляемый текст "+строка.НомерДокумента+" имеет похожесть "+Похожесть+"%");
		КонецЕсли;
		
		стр_н = ТаблицаКлассификатор.Добавить();
		стр_н.Уровень1 = Истина;
		стр_н.Уровень2 = Ложь;
		Если ЗначениеЗаполнено(строка.Тема) Тогда
			стр_н.Тема = строка.Тема;
		Иначе
			Массив = СтрРазделить(СокрЛП(строка.Текст),Символы.ПС,Ложь);
			Если Массив.Количество()>0 Тогда
				стр_н.Тема = Лев(Массив[0],50);
			Иначе
				стр_н.Тема = Лев(строка.ОбработанныйТекст,50);
			КонецЕсли;
		КонецЕсли;
		стр_н.Текст = строка.Текст;
		стр_н.ОбработанныйТекст = строка.ОбработанныйТекст;
		стр_н.НижняяГраница = 0.1;
		стр_н.Изменено = Истина;
	КонецЦикла;
	
КонецПроцедуры


&НаКлиенте
Процедура Тема_ДобавитьПодчиненнуюТему(Команда)
	ВыделенныеСтроки = Элементы.ТаблицаЦветов.ВыделенныеСтроки;
	
	Если ВыделенныеСтроки=Неопределено или ВыделенныеСтроки.Количество()=0 Тогда
		Возврат;
	КонецЕсли;
	
	Родитель = ТаблицаКлассификатор.Индекс(Элементы.ТаблицаКлассификатор.ТекущиеДанные);
	
	Для каждого стр из ВыделенныеСтроки Цикл
		строка = ЭтаФорма.ТаблицаЦветов.Получить(стр);
		
		Похожесть = Тема_ПроверитьНаНаличиеПодобных(строка.ОбработанныйТекст);
		
		Если Похожесть>80 Тогда 
			Сообщить("Добавляемый текст "+строка.НомерДокумента+" уже есть в списке с вероятностью более "+Похожесть+"%. Отказ добавления!");
			Продолжить;
		КонецЕсли;
		
		Если Похожесть>40 Тогда
			Сообщить("Добавляемый текст "+строка.НомерДокумента+" имеет похожесть "+Похожесть+"%");
		КонецЕсли;
		
		Если ТаблицаКлассификатор.Индекс(ТаблицаКлассификатор.Получить(ТаблицаКлассификатор.Количество()-1))=Родитель Тогда
			стр_н = ТаблицаКлассификатор.Добавить();
		Иначе
			стр_н = ТаблицаКлассификатор.Вставить(Родитель+1);
		КонецЕсли;
		стр_н.Уровень1 = Ложь;
		стр_н.Уровень2 = Истина;
		Если ЗначениеЗаполнено(строка.Тема) Тогда
			стр_н.Тема = строка.Тема;
		Иначе
			стр_н.Тема = Лев(строка.ОбработанныйТекст,50);
		КонецЕсли;
		стр_н.Текст = строка.Текст;
		стр_н.ОбработанныйТекст = строка.ОбработанныйТекст;
		стр_н.НижняяГраница = 0.1;
		стр_н.Изменено = Истина;
	КонецЦикла;	
КонецПроцедуры

&НаКлиенте
Процедура Тема_ОбновитьТему(Команда)
	// Вставить содержимое обработчика.
КонецПроцедуры

&НаКлиенте
Процедура Тема_ПрименитьИзменения(Команда)
	Тема_ПрименитьИзмененияНаСервере();
КонецПроцедуры

&НаСервере
Процедура Тема_ПрименитьИзмененияНаСервере()
	
	Если НЕ ЗначениеЗаполнено(Классификатор) Тогда
		Сообщить("Классификатор должен быть выбран");
		Возврат;
	КонецЕсли;
	
	ПредыдущийРодитель = Неопределено;
	
	Для каждого стр из ТаблицаКлассификатор Цикл
		
		КлассОбъект = Неопределено;
		
		Если ЗначениеЗаполнено(стр.Ссылка) Тогда
			КлассОбъект = стр.Ссылка.ПолучитьОбъект();
		Иначе
			КлассОбъект = Справочники.ИзвестныеСитуации.СоздатьЭлемент();
		КонецЕсли;
		
		Если НЕ ЗначениеЗаполнено(стр.Ссылка) Тогда
			КлассОбъект.Наименование = стр.Тема;
		КонецЕсли;
		КлассОбъект.НижняяГраница = стр.НижняяГраница;
		КлассОбъект.Текст = стр.Текст;
		Если стр.Уровень1=Истина Тогда
			КлассОбъект.Родитель = Классификатор;
			ПредыдущийРодитель = Неопределено;
		Иначе
			КлассОбъект.Родитель = ПредыдущийРодитель;
		КонецЕсли;
		
		Попытка
			КлассОбъект.Записать();
			Если стр.Уровень1=Истина Тогда
				ПредыдущийРодитель = КлассОбъект.Ссылка;
			КонецЕсли;
			стр.Ссылка = КлассОбъект.Ссылка;
		Исключение
			Сообщить(ОписаниеОшибки());
		КонецПопытки;
		
		
	КонецЦикла;
	
КонецПроцедуры

&НаСервереБезКонтекста
функция ПолучитьТекстЗапросаПоКлассификатору()

Возврат "ВЫБРАТЬ
	|	ИзвестныеСитуации.Ссылка КАК Ссылка,
	|	ИзвестныеСитуации.Родитель КАК Родитель,
	|	ИзвестныеСитуации.Наименование КАК Наименование,
	|	ИзвестныеСитуации.Наименование КАК Тема,
	|	ИзвестныеСитуации.Текст КАК Текст,
	|	ИзвестныеСитуации.НижняяГраница КАК НижняяГраница
	|ИЗ
	|	Справочник.ИзвестныеСитуации КАК ИзвестныеСитуации
	|ГДЕ
	|	ИзвестныеСитуации.Ссылка В ИЕРАРХИИ(&Корень)
	|
	|УПОРЯДОЧИТЬ ПО
	|	Ссылка ИЕРАРХИЯ";
	
КонецФункции

&НаСервере
Процедура Тема_ОбновитьСоставКлассификатора(Корень)
	
	Запрос = новый Запрос;
	Запрос.Текст = ПолучитьТекстЗапросаПоКлассификатору();
	Запрос.УстановитьПараметр("Корень",Корень);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	ТаблицаКлассификатор.Очистить();
	КешРодителей = новый Соответствие();

	Пока Выборка.Следующий() Цикл
		// корень не добавляем
		Если Выборка.Ссылка=Корень Тогда
			Продолжить;
		КонецЕсли;
		Если Выборка.Родитель=Корень Тогда
			стр_н = ТаблицаКлассификатор.Добавить();
			стр_н.Уровень1 = Истина;
			КешРодителей.Вставить(Выборка.Ссылка,стр_н);
		Иначе
			стр_н = ТаблицаКлассификатор.Вставить(ТаблицаКлассификатор.Индекс(КешРодителей.Получить(Выборка.Родитель))+1);
			стр_н.Уровень2 = Истина;
		КонецЕсли;
		стр_н.Ссылка = Выборка.Ссылка;
		стр_н.Текст = Выборка.Текст;
		стр_н.Тема = Выборка.Наименование;
		стр_н.НижняяГраница = Выборка.НижняяГраница;
	КонецЦикла;	
	
КонецПроцедуры

// определим похожесть текстов
&НаКлиенте
Функция ПохожестьТекстовМетодШинглов(Текст1, Текст2, Ключ1=Неопределено, Ключ2=Неопределено)
	Похожесть = 0;	
	ШагШингла = 3;
	
	// подготовим
	МассивСлов1 = СтрРазделить(Текст1," ",Ложь);
	МассивСлов2 = СтрРазделить(Текст2," ",Ложь);
	
	// получим шинглы
	СоответствиеШинглов1 = КешШинглов.Получить(Ключ1);
	Если СоответствиеШинглов1 = Неопределено Тогда
		СоответствиеШинглов1 = ПолучитьМассивШинглов(МассивСлов1, ШагШингла);
		КешШинглов.Вставить(Ключ1,СоответствиеШинглов1);
	КонецЕсли;
	СоответствиеШинглов2 = КешШинглов.Получить(Ключ2);
	Если СоответствиеШинглов2 = Неопределено Тогда
		СоответствиеШинглов2 = ПолучитьМассивШинглов(МассивСлов2, ШагШингла);
		КешШинглов.Вставить(Ключ2,СоответствиеШинглов2);
	КонецЕсли;
	
	// получим похожесть
	КоличествоСовпадений = 0;
	Для каждого стр из СоответствиеШинглов1 Цикл
		Если НЕ СоответствиеШинглов2.Получить(стр.Ключ)=Неопределено Тогда
			КоличествоСовпадений = КоличествоСовпадений+1;
		КонецЕсли;
	КонецЦикла;
	
	Похожесть = КоличествоСовпадений*2/(СоответствиеШинглов1.Количество()+СоответствиеШинглов2.Количество());
	
	Возврат Похожесть*100;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьМассивШинглов(Знач МассивСлов,Знач ШагШингла=3)
	
	МассивШинглов = новый Массив;
	СоответствиеШинглов = новый Соответствие;
	
	ж=0;
	ТекстШингла = "";
	Для ш=0 по МассивСлов.Количество()-1 Цикл
		ТекстШингла = ТекстШингла+" "+МассивСлов[ш];
		ж=ж+1;
		Если ж=ШагШингла Тогда
			ж=0;
			// захват предыдущего слова
			ш=ш-1;
			Хеш = ПолучитьХешТекста(ТекстШингла);
			МассивШинглов.Добавить(Хеш);
			СоответствиеШинглов.Вставить(Хеш,Истина);
			//СоответствиеШинглов.Вставить(ТекстШингла,Истина);
			ТекстШингла = "";
		КонецЕсли;		
	КонецЦикла;
	
	Хеш = ПолучитьХешТекста(ТекстШингла);
	МассивШинглов.Добавить(Хеш);
	СоответствиеШинглов.Вставить(Хеш,Истина);
	//СоответствиеШинглов.Вставить(ТекстШингла,Истина);
	
	
	Возврат СоответствиеШинглов;

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьХешТекста(Знач ТекстШингла)
	
	Перем Писатель, ПотокПамять, Хеш;
	
	ПотокПамять = Новый ПотокВПамяти;
	Писатель = Новый ЗаписьДанных(ПотокПамять, КодировкаТекста.UTF8,,"","");
	Писатель.ЗаписатьСтроку(ТекстШингла, КодировкаТекста.UTF8);
	Писатель.Закрыть();
	Хеш = новый ХешированиеДанных(ХешФункция.MD5);
	Хеш.Добавить(ПотокПамять.ЗакрытьИПолучитьДвоичныеДанные());  
	Возврат Хеш.ХешСумма;

КонецФункции

&НаКлиенте
Процедура КлассификаторПриИзменении(Элемент)
	Тема_ОбновитьСоставКлассификатора(Классификатор);
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаКлассификаторПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	Если НоваяСтрока=Истина Тогда
		Элемент.ТекущиеДанные.Уровень1 = Истина;
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура УдалитьЛишниеСлова(Команда)
	// Вставить содержимое обработчика.
КонецПроцедуры

// сворачиваем по косинусу
&НаКлиенте
Процедура СвернутьТаблицуЦветов(Команда)
	
	КешСвязиСловДокументов = новый Соответствие;
	Для каждого стр из ТаблицаСвязиСловДокументов Цикл
		КешСвязиСловДокументов.Вставить(стр.guid_Документ,стр);
	КонецЦикла;
	КешКорпусТекстов = новый Соответствие;
	Для каждого стр из ТаблицаКорпусТекстов Цикл
		КешКорпусТекстов.Вставить(стр.guid,стр);
	КонецЦикла;	
	
	МассивСтрокДляУдаления = новый Массив;
	КешСтрокЦветов = новый Соответствие;
	Для каждого стр из ТаблицаЦветов Цикл
		основная = КешСтрокЦветов.Получить(стр.Цвет);
		Если основная=Неопределено Тогда
			КешСтрокЦветов.Вставить(стр.Цвет,стр);
			
			// TODO: вектора как бы надо сложить вектора документов в начальный вектор, который остался
			// думаю отдельная таблица или добавить в эту же , а потом удалят
			guid_Документ = Строка(новый УникальныйИдентификатор());
			НомерДокумента = "tmp"+ТаблицаКорпусТекстов.Количество()+1;
			// 1) добавляем в корпус текстов
			стр_нд = ТаблицаКорпусТекстов.Добавить();
			стр_нд.guid = guid_Документ;
			стр_нд.НомерДокумента = НомерДокумента;
			стр_нд.Текст = стр.Текст;
			стр_нд.ОбработанныйТекст = стр.ОбработанныйТекст;
			стр_нд.КоличествоСлов = 0;
			КешКорпусТекстов.Вставить(guid_Документ,стр_нд);
			// 2) добавляем новый вектор
			стр_н = ТаблицаСвязиСловДокументов.Добавить();
			стр_н.tmp = Истина;
			стр_н.guid_Документ = guid_Документ; 
			стр_н.Документ = НомерДокумента;
			стр_н.Вектор = СкопироватьВектор(КешСвязиСловДокументов.Получить(стр.guid).Вектор);
			КешСвязиСловДокументов.Вставить(guid_Документ,стр_н);
			
			// подменяем ссылку на новый документ сборная солянка
			стр.guid = guid_Документ;
			стр.НомерДокумента = НомерДокумента;
			
			Продолжить;
		КонецЕсли;
		основная.Текст = основная.Текст+Символы.ПС+" ---new_text--- "+Символы.ПС+стр.Текст;
		основная.ОбработанныйТекст = основная.ОбработанныйТекст+" "+стр.ОбработанныйТекст;
		основная.КоличествоВГруппе = основная.КоличествоВГруппе + стр.КоличествоВГруппе;
		КешКорпусТекстов.Получить(основная.guid).Текст = основная.Текст;
		КешКорпусТекстов.Получить(основная.guid).ОбработанныйТекст = основная.ОбработанныйТекст;
		век1 = КешСвязиСловДокументов.Получить(основная.guid).Вектор;
		век2 = КешСвязиСловДокументов.Получить(стр.guid).Вектор;
		ДобавитьВектор(век1,век2);
		МассивСтрокДляУдаления.Добавить(стр);
	КонецЦикла;
	
	

	
	Для каждого стр из МассивСтрокДляУдаления Цикл
		ТаблицаЦветов.Удалить(стр);
	КонецЦикла;
	
	// удалим лишние вхождения ключевых слов
	Для каждого стр из ТаблицаЦветов Цикл
		
		МассивСлов = СтрРазделить(стр.ОбработанныйТекст," ",Ложь);
		КешСлов = новый Соответствие;
		Для каждого слово из МассивСлов Цикл
			КешСлов.Вставить(слово,слово);
		КонецЦикла;
		
		стр.ОбработанныйТекст = "";
		
		Для каждого эл из КешСлов Цикл
			стр.ОбработанныйТекст = стр.ОбработанныйТекст + " "+эл.Ключ;	
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Процедура СформироватьТемы(Команда)
	// получим массив
	Для каждого цвет из ТаблицаЦветов Цикл
		// преобразуем
		ОбработаннаяСтрока = СтрЗаменить(цвет.Текст,Символы.ПС," ");
		ОбработаннаяСтрока = СтрЗаменить(ОбработаннаяСтрока,"---new_text---"," ");
		ОбработаннаяСтрока = ОбработатьТекстДанных(ОбработаннаяСтрока);
		МассивСлов = СтрРазделить(ОбработаннаяСтрока," ",Ложь);
		// получим частоту слов
		КешЧастотаСлов = новый Соответствие;
		Для каждого слово из МассивСлов Цикл
			ЧастотаСлов = КешЧастотаСлов.Получить(слово);
			Если ЧастотаСлов=Неопределено Тогда
				ЧастотаСлов = 0;
			КонецЕсли;
			КешЧастотаСлов.Вставить(слово,ЧастотаСлов+1);
		КонецЦикла;
		// отсортеруем и возьмем самые частые, но не более 10
		СписокЗначений = новый СписокЗначений;
		Для каждого стр из КешЧастотаСлов Цикл
			СписокЗначений.Добавить(стр.Ключ,стр.Значение);
		КонецЦикла;
		СписокЗначений.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
		МассивСлов = СписокЗначений.ВыгрузитьЗначения();
		цвет.Тема = "";
		Для ш=0 по МассивСлов.ВГраница() Цикл
			Если ш>10 Тогда
				Прервать;
			КонецЕсли;
			цвет.Тема = цвет.Тема+" "+МассивСлов[ш];
		КонецЦикла
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура ВыполнитьАвтоматическуюКлассификациюПоКлассификатору(Команда)
	
	НачалоЗамера = ТекущаяДата();
	
	КешОбработанныхСтрокКлассификатора = новый Соответствие;
	
	КешСвязиСловДокументов = новый Соответствие;
	Для каждого стр из ТаблицаСвязиСловДокументов Цикл
		КешСвязиСловДокументов.Вставить(стр.guid_Документ,стр);
	КонецЦикла;
	
	// сбросим
	Для каждого документ из ТаблицаКорпусТекстов Цикл
		документ.КосинусОсновной = 0;
		документ.КосинусВторичный = 0;
		документ.КлассОсновной = Неопределено;
		документ.КлассВторичный = Неопределено;
	КонецЦикла;
	
	// получим список классов и для каждого текста выполним классификацию
	Для каждого документ из ТаблицаКорпусТекстов Цикл
		Для каждого класс из ТаблицаКлассификатор Цикл
			
			КлючКласса = класс.Тема+"/"+Строка(класс.Ссылка.UUID());
			ВекторЗапроса = КешОбработанныхСтрокКлассификатора.Получить(КлючКласса);
			Если ВекторЗапроса=Неопределено Тогда
				// 1. Разберем слово
				ОбработаннаяСтрокаЗапроса = ОбработатьТекстДанных(класс.Текст);
				// 2. Составим вектор
				ОбработаннаяСтрокаЗапроса = СтрЗаменить(ОбработаннаяСтрокаЗапроса,Символы.ПС," ");
				ОбработаннаяСтрокаЗапроса = УдалитьСловаНеВходящиеВБазис(ОбработаннаяСтрокаЗапроса);
				МассивСлов = СтрРазделить(ОбработаннаяСтрокаЗапроса," ",Ложь);
				//МассивСлов = ОбработатьМассивАлгоритмомСтеммингПриНеобходимости(МассивСлов);
				
				//Если Текст_ИспользоватьСтеммерПортера=Истина Тогда
				//	ОбработаннаяСтрокаЗапроса = СтрСоединить(МассивСлов," ");
				//КонецЕсли;
				
				ВекторЗапроса = новый Массив;
				КоличествоСловЗапроса = МассивСлов.Количество();
				КоличествоДокументов = ТаблицаКлассификатор.Количество();
				Если КоличествоДокументов=0 Тогда
					КоличествоДокументов=1;
				КонецЕсли;
				КешВажностиСлов = новый Соответствие;
				
				Для каждого стр из ТаблицаВажностиСлов Цикл
					КешВажностиСлов.Вставить(стр.Слово,стр);
				КонецЦикла;
				
				
				Для каждого эл из ВекторСловСписком Цикл
					стр = эл.Значение;
					
					Точка = новый Структура("Слово,Количество,КоличествоСлов,TF,IDF,TFIDF,Значение",стр.Слово,0,0,0,0,0,0);
					
					КоличествоВхождений = СтрЧислоВхождений(" "+ОбработаннаяСтрокаЗапроса+" "," "+стр.Слово+" ");		
					
					Если КоличествоВхождений>0 Тогда
						
						стрВажность = КешВажностиСлов.Получить(стр.Слово);
						Важность=1;
						Если НЕ стрВажность=Неопределено Тогда
							Важность = стрВажность.Важность;
						КонецЕсли;
						
						Точка.Количество = КоличествоВхождений;
						Точка.TF = Важность*КоличествоВхождений/КоличествоСловЗапроса;			
						Если стр.КоличествоДокументовЭтоСлово=0 Тогда
							стр.КоличествоДокументовЭтоСлово=1;
						КонецЕсли;			
						Точка.IDF =  Log10(КоличествоДокументов/стр.КоличествоДокументовЭтоСлово);
						Точка.TFIDF = Точка.IDF*Точка.TF;
						Точка.Значение = Точка.TFIDF;
					КонецЕсли;
					
					ВекторЗапроса.Добавить(Точка);
					
				КонецЦикла;	
				КешОбработанныхСтрокКлассификатора.Вставить(КлючКласса,ВекторЗапроса);
			КонецЕсли;
			
			Косинус = ПолучитьКосинусВекторов(ВекторЗапроса,КешСвязиСловДокументов.Получить(документ.guid).Вектор);
			
			Если Косинус>класс.НижняяГраница Тогда
				
				Если документ.КосинусОсновной<Косинус Тогда
					документ.КосинусВторичный = документ.КосинусОсновной;
					документ.КлассВторичный = документ.КлассОсновной;
					документ.КосинусОсновной = Косинус;
					документ.КлассОсновной = ?(ЗначениеЗаполнено(класс.Ссылка),класс.Ссылка,класс.Тема);
				ИначеЕсли документ.КосинусВторичный<Косинус Тогда
					документ.КосинусВторичный = Косинус;
					документ.КлассВторичный = ?(ЗначениеЗаполнено(класс.Ссылка),класс.Ссылка,класс.Тема);
				КонецЕсли;
				
			КонецЕсли;
		
		КонецЦикла;
	КонецЦикла;		
	
	Сообщить("Завершено (ВыполнитьАвтоматическуюКлассификациюПоКлассификатору): "+(ТекущаяДата()-НачалоЗамера));
КонецПроцедуры

#КонецОбласти

&НаКлиенте
Процедура ВыполнитьФункционалПоБазе(Команда)
	ВыполнитьФункционалПоБазеСервер();
КонецПроцедуры

&НаСервере
Процедура ВыполнитьФункционалПоБазеСервер()
	ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
	ОбработкаОбъект.ВыполнитьЗагрузкуДанных(Замер);
КонецПроцедуры



ВекторСловСписком = новый СписокЗначений;
КешСтеммераПортера = новый Соответствие;
КешРасчетныхДанных = новый Соответствие;
КешСжатыхВекторов = новый Соответствие;
КешДанныхСжатыхВекторов = новый Соответствие;
МассивЦветов = новый Массив;
КешБазисныхСлов = новый Соответствие;
КешШинглов = новый Соответствие;